[{"id":"d3e49ebf88f6993b40db7660670c9af3","title":"Windows内核","content":"01_环境搭建\nWindows XP Professional 虚拟机\n内存256MB，小一点方便快照\n处理器单核单线程，方便实验，多核具有复杂性\n串口 \\\\.\\pipe\\com_1\nC:\\\\boot.ini 设置调试模式：multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS&#x3D;”Microsoft Windows XP Professional” &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debug &#x2F;debugport&#x3D;com_1 &#x2F;baudrate&#x3D;115200\n\n\nwindbg 启动参数：&quot;C:\\Program Files\\Windows Kits\\10\\Debuggers\\x64\\windbg.exe&quot; -b -k com:pipe,port=\\\\.\\pipe\\com_1,baud=115200,reconnect,resets=0 -y SRV\\*D:\\symbol\\*http://msdl.microsoft.com/download/symbols\nVisual Studio2010 (高版本VS生成的exe文件无法在XP上运行)\nRelease，Win32\n项目属性–配置属性–链接器–随机基址-&gt;否\n项目属性–配置属性–链接器–固定基址-&gt;是\n\n\n\n02_中断提权本节虚拟机内需要安装的工具：\n\nXueTr：查看内核状态\n\n系统中高于0x80000000的地址是内核地址，低于0x80000000的地址是用户地址\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;Windows.h&gt;\n\nDWORD g_tmp &#x3D; 0;\n\n&#x2F;&#x2F; r idtr                           读中断描述符表寄存器\n&#x2F;&#x2F; dq 8003f400 l40                  读中断描述符表\n&#x2F;&#x2F; eq 8003f500  0040ee00&#96;00081000   写中断描述符表，两边即目标函数0x00401000，中间八位是权限描述等\n&#x2F;&#x2F; 写完之后 XueTr 上还是看不到，但是 windbg 能看到，原因是 XueTr 的智能识别识别不了0x00401000函数\n\n&#x2F;&#x2F; 裸函数，没有 push ebp 之类的函数头，方便写汇编\nvoid __declspec(naked) IdtEntry() &#123;\n\t__asm &#123;\n\t\tmov eax, dword ptr ds:[0x8003f014]\n\t\tmov g_tmp, eax  &#x2F;&#x2F; 这里不要用printf，尽量少写代码，printf经过层层调用干了很多事，在0环中是非常危险的\n\t\tiretd           &#x2F;&#x2F; 32位不是iret，是iretd\n\t&#125;\n&#125;\n\n&#x2F;&#x2F; 产生偏移为0x20的中断\nvoid go() &#123;\n\t__asm int 0x20;\n&#125;\n&#x2F;&#x2F; 3环中 int 0 和直接除零异常不同，根据中断描述符表对应的dpl进行不同的处理\n\nint main() &#123;\n\tif ((DWORD)IdtEntry !&#x3D; 0x401000) &#123;\n\t\tprintf(&quot;wrong addr: %p&quot;, IdtEntry);\n\t\texit(-1);\n\t&#125;\n\tgo();\n\tprintf(&quot;%p\\n&quot;, g_tmp);\n\tsystem(&quot;pause&quot;);\n&#125;\n\n注意：能调试内核的原因是启动了debug模式，调试器接管了系统，否则是无法调试内核的\n03_多核复杂性(1)本节虚拟机内需要安装的工具：\n\nCheat Engine 6.x：拥有驱动模块dbk32.sys，可以更改内核地址。第一次启动需要在 设置–其他 全部勾上\n\n注意：乱改内核地址会蓝屏\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;Windows.h&gt;\n\nDWORD g_tmp;\n\nvoid __declspec(naked) IdtEntry() &#123;\n\t__asm &#123; &#x2F;&#x2F; 中断处理进程进来后中断是关闭状态，防止中断嵌套\n        pushfd\n\t\tpop eax\n\t\tmov g_tmp, eax\n        &#x2F;&#x2F; 第九位eflag是中断位\n\t\tiretd\n\t&#125;\n&#125;\n\nvoid go() &#123;\n\t__asm int 0x20;\n&#125;\n\nint main() &#123;\n\tif ((DWORD)IdtEntry !&#x3D; 0x401000) &#123;\n\t\tprintf(&quot;wrong addr: %p&quot;, IdtEntry);\n\t\texit(-1);\n\t&#125;\n\tgo();\n\tprintf(&quot;%p\\n&quot;, g_tmp);\n    &#x2F;&#x2F; 显示46，正常3环会是246\n\tsystem(&quot;pause&quot;);\n&#125;\n\n多核时windbg切换核：\n0: kd&gt; ~1\n1: kd&gt;\n\n\n\n04_多核复杂性(2)#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;Windows.h&gt;\n\nvoid __declspec(naked) IdtEntry() &#123;\n\t__asm &#123;\n        &#x2F;&#x2F; 多核复杂性：想稳定挂钩，涉及到lock页，此处是简单绕过\n        mov eax, cr0         &#x2F;&#x2F; 修改cr0绕过写保护，cr0不能直接与\n        and eax, not 10000h  &#x2F;&#x2F; 取反，同时适用于不同位数的寄存器\n        mov cr0, eax\n        \n        mov eax, 0xffffffff\n        &#x2F;&#x2F; 0x80542520来源于主要系统模块ntkrpamp(ntkrnlpa.exe?)的_KiFastCallEntry(3环进0环的入口)\n        &#x2F;&#x2F; 用ida分析ntkrpamp(ntkrnlpa.exe?)时需要基址重定位\n        mov ds:[0x80542520], eax\n        &#x2F;&#x2F; 这里有个有意思的点：可以修改idt表项，将之前的入口函数地址痕迹清除\n        \n\t\tiretd\n\t&#125;\n&#125;\n\nvoid go() &#123;\n\t__asm int 0x20;\n&#125;\n\nint main() &#123;\n\tif ((DWORD)IdtEntry !&#x3D; 0x401000) &#123;\n\t\tprintf(&quot;wrong addr: %p&quot;, IdtEntry);\n\t\texit(-1);\n\t&#125;\n\tgo();\n\tsystem(&quot;pause&quot;);\n&#125;\n\n\n\n05_中断现场(1)观察中断前和中断后寄存器的变化\n注意：不要用printf来观察，而是如同下面使用全局变量和mov指令进行观察，printf会破坏寄存器现场\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;Windows.h&gt;\n\nDWORD g_esp[2];\n\nvoid __declspec(naked) IdtEntry() &#123;\n\t__asm &#123;\n        mov [g_esp+4], esp\n\t\tiretd\n\t&#125;\n&#125;\n\nvoid go() &#123;\n    __asm&#123;\n        mov [g_esp], esp\n    &#125;\n\t__asm int 0x20;\n&#125;\n\nint main() &#123;\n\tif ((DWORD)IdtEntry !&#x3D; 0x401000) &#123;\n\t\tprintf(&quot;wrong addr: %p&quot;, IdtEntry);\n\t\texit(-1);\n\t&#125;\n\tgo();\n    printf(&quot;%p\\n&quot;, g_esp[0]);\n    printf(&quot;%p\\n&quot;, g_esp[1]);\n\tsystem(&quot;pause&quot;);\n&#125;\n\neax,ebx,ecx,edx,esp,ebp,esi,edi,cs,ds,ss,es,fs,gs\n有改变的寄存器：cs(根据门描述符变化)，ss，esp，eflags，eip\n描述符(用途：①内存区域；②门) gdt idt 保护模式 选择子\n06_中断现场(2)进入0环中断函数后用windbg断下来在windbg寄存器窗口查看fs的值为30，而根据上节的情况观察到fs的值是3B(此值是正确的)，因为断点将信息传输给调试器时进行了大量不可控的操作。“对微观世界的观测会对微观物质产生影响”，调试器侵入内核会对其产生影响。所以不要太依赖调试器\n一个基本观点：调试器的核心代码是不能被进行调试的。\n#include&lt;cstdio&gt;\n#include&lt;cstdlib&gt;\n#include&lt;Windows.h&gt;\n\nDWORD g_8003f038;   &#x2F;&#x2F; 此gdt表项在windbg和XueTr中查看到的值不同(XueTr是正确的)\n\nvoid __declspec(naked) IdtEntry() &#123;\n\t__asm &#123;\n        push eax\n        mov eax, ds:[0x8003f038]\n        mov g_8003f038, eax\n        pop eax\n\t\tiretd\n\t&#125;\n&#125;\n\nvoid go() &#123;\n\t__asm int 0x20;\n&#125;\n\nint main() &#123;\n\tif ((DWORD)IdtEntry !&#x3D; 0x401000) &#123;\n\t\tprintf(&quot;wrong addr: %p&quot;, IdtEntry);\n\t\texit(-1);\n\t&#125;\n\tgo();\n    printf(&quot;%p\\n&quot;, g_8003f038);\n\tsystem(&quot;pause&quot;);\n&#125;\n\nss是esp使用的段，当权限切换的时候伴随着堆栈的切换\n07_中断现场(3)cpu进行线程调度的时候，就把esp内核栈地址和ss地址写入tss\n从0环回3环时栈里依次存储了eip，ring3 cs，ring3 eflags，ring3 esp，ring3 ss的值\n08_再次开中断","slug":"20230915-Windows-Kernel","date":"2023-09-15T02:00:00.000Z","categories_index":"Learn","tags_index":"windows,kernel","author_index":"y9nhjy"},{"id":"f4299006905b671658e489a5612f0ab4","title":"Proxifier注册机","content":"Declaration本项目仅用作学习教育目的, 不用于任何其他用途, 如有侵权请第一时间联系作者删除\nThis project is only for learning and educational purposes and is not intended for any other purpose. If there is any infringement, please contact the author immediately to delete it\n安装软件官网Proxifier - The Most Advanced Proxy Client\n这里下载的是安装版(setup)\n\n一路next下去安装完毕即可\n正向开始启动Proxifier点击Registration Key\n\n随便输入会提示Key格式不对, 为xxxxx-xxxxx-xxxxx-xxxxx-xxxxx, 为方便描述, 本文将每5个字符称为1组, 下文也会提到。然后照着格式再次随便输入查看Key错误时的反馈\n\n接下来, IDA, 启动！搜索字符串The registration Key is incorrect.\n\n定位至此处\n\n通过交叉引用定位关键Check函数\n\nCheck算法char __fastcall Check(unsigned int *a1, _QWORD *a2, __int64 a3)\n&#123;\n  _QWORD *v4; &#x2F;&#x2F; rsi\n  const wchar_t *v6; &#x2F;&#x2F; rdx\n  _QWORD *v8; &#x2F;&#x2F; r8\n  _QWORD *v9; &#x2F;&#x2F; r8\n  _QWORD *v10; &#x2F;&#x2F; r8\n  _QWORD *v11; &#x2F;&#x2F; r8\n  _QWORD *v12; &#x2F;&#x2F; rax\n  __int16 v13; &#x2F;&#x2F; dx\n  _QWORD *v14; &#x2F;&#x2F; rax\n  __int64 v15; &#x2F;&#x2F; rax\n  __int64 v16; &#x2F;&#x2F; rcx\n  int v17; &#x2F;&#x2F; edi\n  int v18; &#x2F;&#x2F; ebx\n  __int64 v19; &#x2F;&#x2F; rax\n  __int64 v20; &#x2F;&#x2F; rcx\n  __int64 v21; &#x2F;&#x2F; rax\n  __int64 v22; &#x2F;&#x2F; rcx\n  int v23; &#x2F;&#x2F; er15\n  __int64 v24; &#x2F;&#x2F; rax\n  unsigned int v25; &#x2F;&#x2F; er15\n  __int64 v26; &#x2F;&#x2F; rcx\n  int v27; &#x2F;&#x2F; eax\n  unsigned int v28; &#x2F;&#x2F; er10\n  unsigned int v29; &#x2F;&#x2F; ecx\n  char v30[32]; &#x2F;&#x2F; [rsp+20h] [rbp-78h] BYREF\n  __int64 v31; &#x2F;&#x2F; [rsp+40h] [rbp-58h]\n  _QWORD *v32; &#x2F;&#x2F; [rsp+48h] [rbp-50h]\n  int v33[4]; &#x2F;&#x2F; [rsp+50h] [rbp-48h] BYREF\n\n  v31 &#x3D; -2i64;\n  v4 &#x3D; a2;\n  v32 &#x3D; a2;\n  if ( a2[2] !&#x3D; 29i64 )\n  &#123;\n    v6 &#x3D; L&quot;Incorrect Key length.&quot;;\nLABEL_3:\n    sub_140003550(a3, v6);\n    unknown_libname_3(v4);\n    return 0;\n  &#125;\n  v8 &#x3D; a2;\n  if ( a2[3] &gt;&#x3D; 8ui64 )\n    v8 &#x3D; (_QWORD *)*a2;\n  sub_1400034B0(a2, v33, (char *)v8 + 46);   &#x2F;&#x2F; 函数作用:去掉&#39;-&#39;\n  v9 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v9 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v9 + 34);\n  v10 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v10 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v10 + 22);\n  v11 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v11 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v11 + 10);   &#x2F;&#x2F; 最终得到&#39;XXXXXXXXXXXXXXXXXXXXXXXXX&#39;\n  v12 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v12 &#x3D; (_QWORD *)*v4;\n  v13 &#x3D; *((_WORD *)v12 + 14);                 &#x2F;&#x2F; 取第3组第5个字符 &#39;4&#39;\n  v14 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v14 &#x3D; (_QWORD *)*v4;\n  *((_WORD *)v14 + 2) &#x3D; v13;                  &#x2F;&#x2F; 第1组第3个字符赋值为第3组第5个字符, 即此字符不影响Key\n  v15 &#x3D; sub_1400037E0(v4, v30, 20i64);        &#x2F;&#x2F; 取第5组字符\n  v17 &#x3D; sub_1400031A0(v16, v15);              &#x2F;&#x2F; 第一个参数:v15一个字符的ascii值\n                                              &#x2F;&#x2F; 此函数的作用:将字符串转换为数字, 本函数可逆\n  v18 &#x3D; v17 ^ (v17 &lt;&lt; 7);\n  v19 &#x3D; sub_1400037E0(v4, v30, 15i64);        &#x2F;&#x2F; 取第4组字符\n  a1[7] &#x3D; sub_1400031A0(v20, v19);\n  v21 &#x3D; sub_1400037E0(v4, v30, 0i64);         &#x2F;&#x2F; 取整个Key的前7个字符\n  v23 &#x3D; sub_1400031A0(v22, v21);\n  v24 &#x3D; sub_1400037E0(v4, v30, 7i64);         &#x2F;&#x2F; 取整个Key的第8-14个字符\n  v25 &#x3D; v18 ^ v23 ^ 0x12345678;               &#x2F;&#x2F; v33的低4字节\n  v27 &#x3D; sub_1400031A0(v26, v24);\n  v33[0] &#x3D; v25;\n  v33[1] &#x3D; v18 ^ v27 ^ 0x87654321;            &#x2F;&#x2F; v33的中4字节\n  v33[2] &#x3D; a1[7];                             &#x2F;&#x2F; v33的高4字节\n  if ( v17 !&#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF) )  &#x2F;&#x2F; 此函数类似CRC32, 目测不可逆\n  &#123;\n    v6 &#x3D; L&quot;Incorrect Key&quot;;\n    goto LABEL_3;\n  &#125;\n  *a1 &#x3D; v25 &gt;&gt; 21;\n  a1[1] &#x3D; HIWORD(v25) &amp; 0x1F;\n  a1[2] &#x3D; (unsigned __int16)v25 &gt;&gt; 5;\n  a1[3] &#x3D; v25 &amp; 0x1F;\n  v29 &#x3D; HIWORD(v28);\n  a1[6] &#x3D; (unsigned __int16)v28;\n  if ( HIWORD(v28) )\n  &#123;\n    a1[4] &#x3D; v29 &#x2F; 0xC + 2000;\n    a1[5] &#x3D; v29 % 0xC;\n  &#125;\n  else\n  &#123;\n    *((_QWORD *)a1 + 2) &#x3D; 0i64;\n  &#125;\n  unknown_libname_3(v4);\n  return 1;\n&#125;\n\n前面会检查Key的长度是否为29, 即XXXXX-XXXXX-XXXXX-XXXXX-XXXXX的长度\n然后主要需要分析sub_1400034B0, sub_1400037E0, sub_1400031A0, sub_140003260这4个函数的功能\n\n本地调试直接步过看Key的变化, 很容易就能看出sub_1400034B0的功能, 即去掉 ‘-‘\n\nsub_1400037E0, 同样的办法可以看出此函数是取出Key的部分字符\n\n然后就是sub_1400031A0, 进去看看\n  __int64 __fastcall sub_1400031A0(__int64 a1, __int64 a2)\n&#123;\n  unsigned int v2; &#x2F;&#x2F; ebx\n  int v3; &#x2F;&#x2F; eax\n  __int64 i; &#x2F;&#x2F; r8\n  __int64 v5; &#x2F;&#x2F; rax\n  unsigned __int16 v6; &#x2F;&#x2F; ax\n\n  v2 &#x3D; 0;\n  v3 &#x3D; *(_DWORD *)(a2 + 16) - 1;\n  for ( i &#x3D; v3; i &gt;&#x3D; 0; --i )\n  &#123;\n    v2 *&#x3D; 32;\n    v5 &#x3D; a2;\n    if ( *(_QWORD *)(a2 + 24) &gt;&#x3D; 8ui64 )\n      v5 &#x3D; *(_QWORD *)a2;\n    v6 &#x3D; *(_WORD *)(v5 + 2 * i);\n    switch ( v6 )\n    &#123;\n      case &#39;W&#39;:\n        continue;\n      case &#39;X&#39;:\n        v6 &#x3D; 79;\n        break;\n      case &#39;Y&#39;:\n        v2 &#x3D; v2 - 48 + 49;\n        continue;\n      case &#39;Z&#39;:\n        v6 &#x3D; 73;\n        break;\n      default:\n        if ( (unsigned __int16)(v6 - 48) &lt;&#x3D; 9u )\n        &#123;\n          v2 &#x3D; v6 + v2 - 48;\n          continue;\n        &#125;\n        break;\n    &#125;\n    v2 &#x3D; v6 + v2 - 55;\n  &#125;\n  unknown_libname_3(a2);\n  return v2;\n&#125;\n\n  可以自己跟着写一遍此算法, 主要作用：将字符串根据此算法转换为数字并返回, 此函数的python实现可以参考本人y9nhjy&#x2F;Proxifier_Keygen 项目中Proxifier_Checker.py里的handle函数\n\nsub_140003260：算法类似CRC32, 目测不可逆\n\n\n最后总结Check完整逻辑：\n\n去除 ‘-‘\n将第1组第3个字符赋值为第3组第5个字符\nv17：第5组字符经过handle函数所生成的数字\nv18 &#x3D; v17 ^ (v17 &lt;&lt; 7)\nv23：取整个Key的前7个字符经过handle函数所生成的数字\nv27：取整个Key的第8-14个字符经过handle函数所生成的数字\nv33的低4字节：v18 ^ v23 ^ 0x12345678\nv33的中4字节：v18 ^ v27 ^ 0x87654321\nv33的高4字节：第4组字符经过handle函数所生成的数字\n最后比较 v17 !&#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF)\n\n逆向项目源代码：y9nhjy&#x2F;Proxifier_Keygen , 欢迎star\n既然sub_140003260不可逆, 就考虑构造v33\n目前已知v33, 逆推Key的流程：\n\n根据高4字节逆推第4组字符\n根据v17 &#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF)得到v17后可逆推第5组字符和得到v18\nv23 &#x3D; v33的低4字节 ^ v18 ^ 0x12345678, 然后逆推出Key的前7个字符\nv27 &#x3D; v33的中4字节 ^ v18 ^ 0x87654321, 然后逆推出Key的第8-14个字符\nKey的第15个字符即Key的第3个字符\n随机生成Key的第3个字符\n得到最终的Key\n\n注意事项：\n\nv33的1~2字节小于0x2580是过期的Key, 高两字节是产品版本, 为0则是安装版, 1是便携版, 2是Mac版\nv33的7~8字节是证书有效期, 为零直接无限期\nKey的第3位不影响Key, 但是不能为 ‘Y’, 否则版本对不上\n\n碎碎念断断续续调了几天, 将Check算法还原成功后, 参考了Danz17&#x2F;Proxifier-Keygen注册机的源代码, 学到了不少, 对其中的流程也更加清晰, 最终总算是实现了注册机的编写, 欢迎各位师傅给我的项目star, 传送门：y9nhjy&#x2F;Proxifier_Keygen \n时隔满满一年终于更新了, 之前电脑出问题系统重装数据全没了, 包括博客, 血压拉满, 就一直没再折腾博客, 这次重新搭建博客, 更换了一个更酷炫的主题, 整体还是比较满意, 就这样吧。\n","slug":"20230816-Proxifier-Keygen","date":"2023-08-16T03:00:00.000Z","categories_index":"Keygen","tags_index":"reverse,keygen","author_index":"y9nhjy"},{"id":"63c1d1c611bd361be9cbbdc1ef690d2f","title":"2022-HWS夏令营线下赛","content":"2022-HWS夏令营线下赛\n比赛：HWS计划第五期-2022硬件安全在线夏令营线下赛\n时间：2022-08-15 17:00:00~2022-08-01 22:00:00\n“有趣”的蒙哥马利\n跳动的AES\n“有趣”的蒙哥马利采集波形\n低通滤波阈值99\n根据hint 每个循环会做一次乘运算和模运算 所以需要将两端波分为一组循环\n根据不断试错 发现每组循环如我标的位置波形表示了乘运算的不同\n一低一高为程序中e[i] &#x3D;&#x3D; 1的情况\n如下\n\n\n\n\nBECD\n跳动的AES低通滤波 + 静态对齐 + 纵向对齐 + 1阶cpa分析密钥 * 16times\n","slug":"20220815-hws-live","date":"2022-08-15T03:00:00.000Z","categories_index":"Write Up","tags_index":"ctf,wp,reverse","author_index":"y9nhjy"},{"id":"5bb046c422c129abba05bb14d8709ec6","title":"2022-HWS&强网杯-复现","content":"2022-HWS&amp;强网杯-复现\nHWS\n​\tre2\n​\tre3\n强网杯\n​\tGameMaster\n​\teasyre\nHWSre2拿到源文件re2.exe，放进ida32里，反编译主函数\nint __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  char v3; &#x2F;&#x2F; bl\n  char v4; &#x2F;&#x2F; al\n  int v5; &#x2F;&#x2F; ecx\n  struct _EXCEPTION_REGISTRATION_RECORD *v7; &#x2F;&#x2F; [esp+0h] [ebp-18h]\n  void *v8; &#x2F;&#x2F; [esp+4h] [ebp-14h]\n\n  v8 &#x3D; &amp;loc_401450;\n  v7 &#x3D; NtCurrentTeb()-&gt;NtTib.ExceptionList;\n  v3 &#x3D; 0;\n  do\n  &#123;\n    v4 &#x3D; sub_40491D(v7, v8);\n    v5 &#x3D; v3++;\n    byte_41B2EC[v5] &#x3D; v4;\n  &#125;\n  while ( v4 !&#x3D; 10 );\n  byte_41B2EC[v3] &#x3D; 0;\n  dword_41B2E8 &#x3D; (char)(v3 - 1);\n  __debugbreak();\n  __debugbreak();\n  __debugbreak();\n  return 0;\n&#125;\n\n暂时看不出来什么，惯例打开字符串窗口查一查\n发现两条可疑的字符串\n\n\n这两条字符串都指向同一个函数\nintptr_t sub_4013D0()\n&#123;\n  int i; &#x2F;&#x2F; [esp+Ch] [ebp-4h]\n\n  for ( i &#x3D; 0; byte_41B2EC[i] &amp;&amp; i &lt;&#x3D; 8; ++i )\n  &#123;\n    if ( (i ^ byte_41B2EC[i]) !&#x3D; byte_41A8B4[i] )\n      goto LABEL_7;\n  &#125;\n  sub_401010((int)off_41A8B0);\n  _loaddll(0);\nLABEL_7:\n  sub_401010((int)&quot;wrong\\n&quot;);\n  return _loaddll(0);\n&#125;\n\n接下来就很简单了，根据逻辑写exp\na &#x3D; [0x46, 0x40, 0x49, 0x46, 0x7F, 0x52, 0x6E, 0x46, 0x7C, 0x24, 0x6B, 0x26, 0x5C, 0x64, 0x7A, 0x5B, 0x49, 0x6C]\nfor i in range(len(a)):\n    print(chr(a[i] ^ i), end&#x3D;&#39;&#39;)\n\nFAKE&#123;WhAt-a-PitTY&#125;\n真的{很好} (痴呆🤤)\n从头再来\n根据这位师傅的wp\nREVERSE-COMPETITION-HWS-5TH-2022\n发现了Tls函数，第一次知道这个函数，了解了一下，以后需要多注意此类型函数\n代码逆向分析领域中，TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用反调试。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术的使用。\nTLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样。\n\n接着分析此函数\nvoid __stdcall TlsCallback_0(int a1, DWORD flOldProtect, int a3)\n&#123;\n  int i; &#x2F;&#x2F; eax\n\n  if ( flOldProtect &#x3D;&#x3D; 1 )\n  &#123;\n    VirtualProtect(StartAddress, 0x320u, 0x40u, &amp;flOldProtect);\n    for ( i &#x3D; 0; i &lt; 800; ++i )\n      *((_BYTE *)StartAddress + i) ^&#x3D; i;\n    CreateThread(0, 0, StartAddress, 0, 0, 0);\n  &#125;\n&#125;\n\n这是一段SMC，明显特征为将一段数组作为函数调用\n先将这段代码还原\nimport idc\nstart_addr &#x3D; 0x401040\nend_addr &#x3D; start_addr + 800\nfor addr in range(start_addr, end_addr):\n    i &#x3D; addr - start_addr\n    by &#x3D; idc.get_wide_byte(addr)\n    ida_bytes.patch_byte(addr, by ^ i)\n\n还原后还有少部分代码ida没有分析到位，找到那些地方按c分析代码\n分析完毕之后再选中StaatAddress这一大段代码，按p创建函数，这样就可以反编译了\nDWORD __stdcall StartAddress(LPVOID lpThreadParameter)\n&#123;\n  int k; &#x2F;&#x2F; ebx\n  int v4; &#x2F;&#x2F; [esp-Ch] [ebp-50548h]\n  int v5; &#x2F;&#x2F; [esp-8h] [ebp-50544h]\n  int v6[65534]; &#x2F;&#x2F; [esp+Ch] [ebp-50530h]\n  char v7[66816]; &#x2F;&#x2F; [esp+40004h] [ebp-10538h] BYREF\n  int v8[6]; &#x2F;&#x2F; [esp+50504h] [ebp-38h]\n  char *v9; &#x2F;&#x2F; [esp+5051Ch] [ebp-20h]\n  int v10; &#x2F;&#x2F; [esp+50520h] [ebp-1Ch]\n  int v11; &#x2F;&#x2F; [esp+50524h] [ebp-18h]\n  int v12; &#x2F;&#x2F; [esp+50528h] [ebp-14h]\n  int v13; &#x2F;&#x2F; [esp+5052Ch] [ebp-10h]\n  int i; &#x2F;&#x2F; [esp+50530h] [ebp-Ch]\n  int v15; &#x2F;&#x2F; [esp+50534h] [ebp-8h]\n  int j; &#x2F;&#x2F; [esp+50538h] [ebp-4h]\n\n  while ( !dword_41B2E4 )\n    Sleep(0x3E8u);\n  for ( i &#x3D; 0; i &lt; 112; ++i )\n    byte_41B30A +&#x3D; *((_BYTE *)sub_401450 + i);\n  for ( i &#x3D; 0; input[i]; ++i )\n    input[i] ^&#x3D; byte_41B30A;\n  v8[0] &#x3D; &#39;Q&#39;;\n  v8[1] &#x3D; &#39;f&#39;;\n  v8[2] &#x3D; &#39;r&#39;;\n  v8[3] &#x3D; &#39;o&#39;;\n  v8[4] &#x3D; &#39;s&#39;;\n  v8[5] &#x3D; &#39;t&#39;;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; j;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n    v7[j + 0x10000] &#x3D; v8[j % 6];\n  v15 &#x3D; 0;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n  &#123;\n    v15 &#x3D; (v7[j + 0x10000] + *(_DWORD *)&amp;v7[4 * j + 65792] + v15) % 256;\n    v12 &#x3D; *(_DWORD *)&amp;v7[4 * j + 65792];\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; *(_DWORD *)&amp;v7[4 * v15 + 65792];\n    *(_DWORD *)&amp;v7[4 * v15 + 65792] &#x3D; v12;\n  &#125;\n  v13 &#x3D; dword_41B2E8;\n  v11 &#x3D; 0;\n  v15 &#x3D; 0;\n  j &#x3D; 0;\n  while ( v13-- )\n  &#123;\n    j &#x3D; (j + 1) % 256;\n    v15 &#x3D; (*(_DWORD *)&amp;v7[4 * j + 65792] + v15) % 256;\n    v12 &#x3D; *(_DWORD *)&amp;v7[4 * j + 65792];\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; *(_DWORD *)&amp;v7[4 * v15 + 65792];\n    *(_DWORD *)&amp;v7[4 * v15 + 65792] &#x3D; v12;\n    v10 &#x3D; (*(_DWORD *)&amp;v7[4 * v15 + 65792] + *(_DWORD *)&amp;v7[4 * j + 65792]) % 256;\n    v6[v11++] &#x3D; *(_DWORD *)&amp;v7[4 * v10 + 65792];\n  &#125;\n  for ( j &#x3D; 0; j &lt; dword_41B2E8; ++j )\n    v7[j] &#x3D; LOBYTE(v6[j]) ^ input[j];\n  v9 &#x3D; v7;\n  for ( k &#x3D; 0; k &lt; dword_41B2E8; ++k )\n  &#123;\n    if ( v9[k] !&#x3D; *(_BYTE *)(k + 0x401307) )\n    &#123;\n      sub_401010(4199237);\n      _loaddll(0);\n      break;\n    &#125;\n  &#125;\n  sub_401010((int)&quot;right\\n&quot;);\n  getchar(v4, v5);\n  return 0;\n&#125;\n\n此处先将input(也就是flag)与byte_41B30A异或，然后对input进行RC4加密，密钥为Qfrost\n根据逻辑求出byte_41B30A\nimport idc\nstart_addr &#x3D; 0x401450\nend_addr &#x3D; start_addr + 112\nbyte_41B30A &#x3D; 0\nfor addr in range(start_addr, end_addr):\n    byte_41B30A +&#x3D; idc.get_wide_byte(addr)\nprint(hex(byte_41B30A &amp; 0xff))\n0x48\n\n根据最后判断的地方0x401307拿到密文\n借用师傅的脚本\n#include&lt;stdio.h&gt;\n\n&#x2F;&#x2F;RC4初始化函数\nvoid rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123;\n\tunsigned int i &#x3D; 0, j &#x3D; 0;\n\tchar k[256] &#x3D; &#123; 0 &#125;;\n\tunsigned char tmp &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; 256; i++) &#123;\n\t\ts[i] &#x3D; i;\n\t\tk[i] &#x3D; key[i % Len_k];\n\t&#125;\n\tfor (i &#x3D; 0; i &lt; 256; i++) &#123;\n\t\tj &#x3D; (j + s[i] + k[i]) % 256;\n\t\ttmp &#x3D; s[i];\n\t\ts[i] &#x3D; s[j];\n\t\ts[j] &#x3D; tmp;\n\t&#125;\n&#125;\n\n&#x2F;*\nRC4加解密函数\nunsigned char* Data     加解密的数据\nunsigned long Len_D     加解密数据的长度\nunsigned char* key      密钥\nunsigned long Len_k     密钥长度\n*&#x2F;\nvoid rc4_crypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k)&#123;\n\tunsigned char s[256];\n\trc4_init(s, key, Len_k);\n\tint i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;\n\tunsigned long k &#x3D; 0;\n\tunsigned char tmp;\n\tfor (k &#x3D; 0; k &lt; Len_D; k++) &#123;\n\t\ti &#x3D; (i + 1) % 256;\n\t\tj &#x3D; (j + s[i]) % 256;\n\t\ttmp &#x3D; s[i];\n\t\ts[i] &#x3D; s[j];\n\t\ts[j] &#x3D; tmp;\n\t\tt &#x3D; (s[i] + s[j]) % 256;\n\t\tData[k] &#x3D; Data[k] ^ s[t];\n\t&#125;\n&#125;\n\nint main()&#123;\n\t&#x2F;&#x2F;字符串密钥\n\tunsigned char key[] &#x3D; &quot;Qfrost&quot;;\n\tunsigned long key_len &#x3D; sizeof(key) - 1;\n\t&#x2F;*\n\t&#x2F;&#x2F;数组密钥\n\tunsigned char key[] &#x3D; &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;\n\tunsigned long key_len &#x3D; sizeof(key);\n    *&#x2F;\n\t&#x2F;&#x2F;加解密数据\n\tunsigned char data[] &#x3D; &#123;0x7F, 0xB6, 0x88, 0x12, 0xDC, 0xC3, 0xDE, 0xDB, 0x30, 0x24, \n    0xE3, 0xC1, 0x0F, 0xC9, 0x7F, 0xC2, 0x4D, 0x9C, 0x6B, 0x02, \n    0x26, 0x20, 0xF1, 0x25, 0xA0, 0xE3, 0xC6, 0xDE &#125;;\n\t&#x2F;&#x2F;加解密\n\trc4_crypt(data, sizeof(data), key, key_len);\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(data); i++)&#123;\n\t\tprintf(&quot;%c&quot;, data[i] ^ 0x48);  &#x2F;&#x2F;0x48即byte_41B30A\n\t&#125;\n\treturn 0;\n&#125;\n\nQDbg-Is_an_1ntereSting-Game!\nre3拿到源文件ctf.apk，放进jadx中，找到MainActicity\n\n发现关键在于这个native check函数，用apktool反编译apk，进入lib目录，将里面的so文件放进ida\n容易找到关键函数：\nbool __fastcall sub_D060(int a1, int a2, int a3)\n&#123;\n  const char *v4; &#x2F;&#x2F; [sp+20h] [bp-490h]\n  size_t i; &#x2F;&#x2F; [sp+28h] [bp-488h]\n  size_t v9; &#x2F;&#x2F; [sp+7Ch] [bp-434h]\n  char v10[272]; &#x2F;&#x2F; [sp+80h] [bp-430h] BYREF\n  char v11[272]; &#x2F;&#x2F; [sp+190h] [bp-320h] BYREF\n  int v12[132]; &#x2F;&#x2F; [sp+2A0h] [bp-210h] BYREF\n\n  memset(v12, 0, 0x204u);\n  v12[0] &#x3D; 1024;\n  memset(v11, 0, sizeof(v11));\n  memset(v10, 0, sizeof(v10));\n  v4 &#x3D; (const char *)_JNIEnv::GetStringUTFChars(a1, a3, 0);\n  v9 &#x3D; strlen(v4);\n  if ( (unsigned __int8)v9 &lt;&lt; 31 || v9 &gt; 0x200 || v9 &lt;&#x3D; 0xF )\n    return 0;\n  for ( i &#x3D; 0; i &lt; v9 &gt;&gt; 1; ++i )\n  &#123;\n    v10[i] &#x3D; v4[2 * i] - 48;\n    if ( (unsigned __int8)v10[i] &gt;&#x3D; 0xAu )\n      v10[i] -&#x3D; 39;\n    v10[i] +&#x3D; 36 * v4[2 * i + 1] + 64;\n  &#125;\n  _memcpy_chk((char *)&amp;v12[38] + 3, &amp;unk_7721, 105, 361);\n  _memcpy_chk((char *)&amp;v12[128] + 1, &amp;unk_778A, 3, 3);\n  sub_2304(v11);\n  return strncmp(&amp;v11[108], sure_flag, 0x14u) &#x3D;&#x3D; 0;\n&#125;\n\nfor循环是转换36进制的字符串为16进制\nsub_31D0据wp说是RSA加密函数，ttttcl看不出来，n和e已知\n最后将得到的值和sure_flag作比较\nsure_flag:49 20 61 6D 20 73 75 72 65 20 69 74 20 69 73 20 66 6C 34 67 00\n借用exp\nimport gmpy2\n\nn &#x3D; 0x7019325b70f4a2f26e921102a0206de415caeb535cd4ec9d23d6608630dd00a9db5db8faef4621ccb2e775844c7447a1a843ebac03eca6f329feabcd6560b80aacf7a54a298548827c9d75e1450fcf7e53dac37c0f7fd25d509c342c23bda0619504b28ec903c56c87\np &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307026173067\nq &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307046219549\nr &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307129708089\ne &#x3D; 0x10001\nphi &#x3D; (p - 1) * (q - 1) * (r - 1)\nd &#x3D; gmpy2.invert(e, phi)\nc &#x3D; 0x4920616D207375726520697420697320666C3467\nm &#x3D; gmpy2.powmod(c, d, n)\ns &#x3D; hex(m)[2:]\nflag &#x3D; &quot;&quot;\nfor i in range(0, len(s), 2):\n    tmp &#x3D; int(s[i:i + 2], 16)\n    if tmp &lt; 100:\n        flag +&#x3D; &quot;0&quot;\n    flag +&#x3D; str(tmp)\nprint(flag)\n\n037087131219012107229231067248093076089082070175138132195124126254031088197066063081248248223201185154047168242228140155089071245228045160218140167117182217137118206104215018068031237111113041220252131252040018130017184197145113066057103096226240251147039224115177108218078236161028053035089246229073211242029209057\n\n输入程序中验证正确\n强网杯GameMaster拿到题目三个文件\n\n核心文件BlackjackConsole.exe易知是基于.NET框架，c#编写的文件\n所以我们用神器dnSpy打开它\n\n进入Program分析，因为c#也是面对对象的，所以有java基础的话看代码还是比较好懂的\n单独分析19行到23行这几句代码，因为它非常显眼，对题目中的”gamemessage”文件进行了操作\n19\t\t\tFileStream fileStream &#x3D; File.OpenRead(&quot;gamemessage&quot;);\n20\t\t\tint num &#x3D; (int)fileStream.Length;\n21\t\t\tProgram.memory &#x3D; new byte[num];\n22\t\t\tfileStream.Position &#x3D; 0L;\n23\t\t\tfileStream.Read(Program.memory, 0, num);\n\n就是将gamemessage里的内容读取到了新创的的一个byte数组memory中\n接着往下分析，这些是游戏初始化的内容，不是重点，一直往下滑发现这一段\n567\t\t\t\tfor (int i &#x3D; 0; i &lt; Program.memory.Length; i++)\n568\t\t\t\t&#123;\n569\t\t\t\t\tbyte[] array &#x3D; Program.memory;\n570\t\t\t\t\tint num &#x3D; i;\n571\t\t\t\t\tarray[num] ^&#x3D; 34;\n572\t\t\t\t&#125;\n573\t\t\t\tEnvironment.SetEnvironmentVariable(&quot;AchivePoint1&quot;, game.Player.Balance.ToString());\n\n这一段对memory进行了异或34的操作\n继续往下，发现\n813\t            byte[] key &#x3D; new byte[]\n814             &#123;\n815                 66,\n816                 114,\n817                 97,\n818                 105,\n819                 110,\n820                 115,\n821                 116,\n822                 111,\n823                 114,\n824                 109,\n825                 105,\n826                 110,\n827                 103,\n828                 33,\n829                 33,\n830                 33\n831             &#125;;\n832             ICryptoTransform cryptoTransform &#x3D; new RijndaelManaged\n833             &#123;\n834                 Key &#x3D; key,\n835                 Mode &#x3D; CipherMode.ECB,\n836                 Padding &#x3D; PaddingMode.Zeros\n837             &#125;.CreateDecryptor();\n838             Program.m &#x3D; cryptoTransform.TransformFinalBlock(Program.memory, 0, Program.memory.Length);\n839             Environment.SetEnvironmentVariable(&quot;AchivePoint2&quot;, game.Player.Balance.ToString());\n\nkey数组，ECB模式，Zeros填充，对memory进行加密，查文档得知此为AES加密\n既然知道对gamemessage进行了什么操作，那么我们开始复现这两个操作\n首先是读取gamemessage，将其对34进行异或得到gamemessage_2文件\nwith open(&#39;gamemessage&#39;,&#39;rb&#39;) as f:\n    with open(&#39;gamemessage_2&#39;,&#39;wb&#39;) as f_2:\n        b&#x3D;f.read()\n        for i in range(len(b)):\n            f_2.write((b[i] ^ 34).to_bytes(1,&#39;little&#39;))\n\n再对其进行AES解密，密钥为b’Brainstorming!!!’，ECB模式，Zeros填充\n\n将解密出来的数据写入文件gamemessage_AES中，再用010 editor打开\n\n发现头部很多可疑信息类似系统API的东西\n可以用binwalk扫一下\n\n果然发现在0x13EB处有PE文件头标志”MZ”\n\n直接把”MZ”之前的数据删掉，得到新的PE文件，它仍是.NET框架下的文件，再用dnSpy打开它\n发现这么段代码\nusing System;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace T1Class&#123;\n\t&#x2F;&#x2F; Token: 0x02000002 RID: 2\n\tpublic class T1&#123;\n\t\t&#x2F;&#x2F; Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250\n\t\tprivate static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream)&#123;\n\t\t\tint num &#x3D; -1;\n\t\t\tfor (int i &#x3D; 0; i &lt; 320; i++)&#123;\n\t\t\t\tx &#x3D; (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1UL) | x &lt;&lt; 1);\n\t\t\t\ty &#x3D; (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1UL) | y &lt;&lt; 1);\n\t\t\t\tz &#x3D; (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1UL) | z &lt;&lt; 1);\n\t\t\t\tbool flag &#x3D; i % 8 &#x3D;&#x3D; 0;\n\t\t\t\tif (flag)&#123;\n\t\t\t\t\tnum++;\n\t\t\t\t&#125;\n\t\t\t\tKeyStream[num] &#x3D; (byte)((long)((long)KeyStream[num] &lt;&lt; 1) | (long)((ulong)((uint)((z &gt;&gt; 32 &amp; 1UL &amp; (x &gt;&gt; 30 &amp; 1UL)) ^ (((z &gt;&gt; 32 &amp; 1UL) ^ 1UL) &amp; (y &gt;&gt; 31 &amp; 1UL))))));\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Token: 0x06000002 RID: 2 RVA: 0x00002110 File Offset: 0x00000310\n\t\tprivate static void ParseKey(ulong[] L, byte[] Key)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 3; i++)&#123;\n\t\t\t\tfor (int j &#x3D; 0; j &lt; 4; j++)&#123;\n\t\t\t\t\tKey[i * 4 + j] &#x3D; (byte)(L[i] &gt;&gt; j * 8 &amp; 255UL);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Token: 0x06000003 RID: 3 RVA: 0x0000215C File Offset: 0x0000035C\n\t\tpublic T1()&#123;\n\t\t\ttry&#123;\n\t\t\t\tstring environmentVariable &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint1&quot;);\n\t\t\t\tstring environmentVariable2 &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint2&quot;);\n\t\t\t\tstring environmentVariable3 &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint3&quot;);\n\t\t\t\tbool flag &#x3D; environmentVariable &#x3D;&#x3D; null || environmentVariable2 &#x3D;&#x3D; null || environmentVariable3 &#x3D;&#x3D; null;\n\t\t\t\tif (!flag)&#123;\n\t\t\t\t\tulong num &#x3D; ulong.Parse(environmentVariable);\n\t\t\t\t\tulong num2 &#x3D; ulong.Parse(environmentVariable2);\n\t\t\t\t\tulong num3 &#x3D; ulong.Parse(environmentVariable3);\n\t\t\t\t\tulong[] array &#x3D; new ulong[3];\n\t\t\t\t\tbyte[] array2 &#x3D; new byte[40];\n\t\t\t\t\tbyte[] array3 &#x3D; new byte[40];\n\t\t\t\t\tbyte[] array4 &#x3D; new byte[12];\n\t\t\t\t\tbyte[] first &#x3D; new byte[]&#123;\n\t\t\t\t\t\t101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191,110,179,227,5,62,9,13,17,65,22,37,5\n\t\t\t\t\t&#125;;\n\t\t\t\t\tbyte[] array5 &#x3D; new byte[]&#123;\n\t\t\t\t\t\t60,100,36,86,51,251,167,108,116,245,207,223,40,103,34,62,22,251,227\n\t\t\t\t\t&#125;;\n\t\t\t\t\tarray[0] &#x3D; num;\n\t\t\t\t\tarray[1] &#x3D; num2;\n\t\t\t\t\tarray[2] &#x3D; num3;\n\t\t\t\t\tT1.Check1(array[0], array[1], array[2], array2);\n\t\t\t\t\tbool flag2 &#x3D; first.SequenceEqual(array2);\n\t\t\t\t\tif (flag2)&#123;\n\t\t\t\t\t\tT1.ParseKey(array, array4);\n\t\t\t\t\t\tfor (int i &#x3D; 0; i &lt; array5.Length; i++)&#123;\n\t\t\t\t\t\t\tarray5[i] ^&#x3D; array4[i % array4.Length];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tMessageBox.Show(&quot;flag&#123;&quot; + Encoding.Default.GetString(array5) + &quot;&#125;&quot;, &quot;Congratulations!&quot;, MessageBoxButtons.OK);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcatch (Exception)&#123;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n逻辑大致如下：求flag-&gt;已知array5-&gt;求array4-&gt;ParseKey函数-&gt;求array-&gt;Check1函数-&gt;求array2-&gt;已知first\n根据这位师傅的wp\n[2022强网杯 ”Reverse“ WP](https://blog.jamiexu.cn/2022/08/01/【CTF&amp;WriteUP&amp;Re】2022强网杯 ”Reverse“ WriteUp&#x2F;)\nexp求解array\nimport z3\n\nfirst &#x3D; [\n  101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106, 20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5\n]\narray2 &#x3D; [0] * len(first)\nx &#x3D; z3.BitVec(&quot;x&quot;, 64)\ny &#x3D; z3.BitVec(&quot;y&quot;, 64)\nz &#x3D; z3.BitVec(&quot;z&quot;, 64)\nnum &#x3D; -1\nfor i in range(320):\n    x &#x3D; (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1)\n    y &#x3D; (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1)\n    z &#x3D; (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1)\n    if i % 8 &#x3D;&#x3D; 0:\n        num +&#x3D; 1\n    array2[num] &#x3D; ((array2[num] &lt;&lt; 1) | (z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1) ^ ((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1)))\n\nsolver &#x3D; z3.Solver()\nfor i in range(len(first)):\n    solver.add(first[i] &#x3D;&#x3D; array2[i])\n\nif solver.check() &#x3D;&#x3D; z3.sat:\n    model &#x3D; solver.model()\n    print(model)\n \n[y &#x3D; 868387187, x &#x3D; 156324965, z &#x3D; 3131229747]\n\n最后直接异或就行了\narray &#x3D; [156324965, 868387187, 3131229747]\narray4 &#x3D; [0] * 12\nfor i in range(3):\n    for j in range(4):\n        array4[i * 4 + j] &#x3D; (array[i] &gt;&gt; j * 8 &amp; 255)\n\narray5 &#x3D; [60, 100, 36, 86, 51, 251, 167, 108, 116, 245, 207, 223, 40, 103, 34, 62, 22, 251, 227]\nfor i in range(len(array5)):\n    print(chr(array5[i] ^ array4[i % len(array4)]), end&#x3D;&#39;&#39;)\n\nY0u_@re_G3meM3s7er!\neasyre题目的提示是flag藏在输入里面，先放在一边，可能会用上\n拿到源文件，查一下是64位elf文件放进ida64里\n__int64 __fastcall sub_4021BB(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)\n&#123;\n  double v10; &#x2F;&#x2F; xmm4_8\n  double v11; &#x2F;&#x2F; xmm5_8\n  unsigned int v13; &#x2F;&#x2F; [rsp+1Ch] [rbp-4h]\n\n  sub_402150();\n  v13 &#x3D; sub_44B420();\n  if ( v13 )\n  &#123;\n    sub_401F2F(v13);\n    sub_40C3F0((__int64)&quot;re3&quot;);\n  &#125;\n  else\n  &#123;\n    sub_44CC50(0LL, 0LL, 0LL, 0LL);\n    sub_44B680((__int64)&quot;re3&quot;, (__int64)&quot;re3&quot;, a3, a4, a5, a6, v10, v11, a9, a10, *(_QWORD *)(a2 + 8), 0LL);\n  &#125;\n  return 0LL;\n&#125;\n\n进入第一个函数sub_402150()看看\n__int64 sub_402150()\n&#123;\n  __int64 v1; &#x2F;&#x2F; [rsp+8h] [rbp-8h]\n\n  v1 &#x3D; sub_40CFA0(&quot;re3&quot;, &quot;wb&quot;);\n  sub_40CFB0(&amp;unk_4BC380, 1LL, (unsigned int)dword_4C2070, v1);\n  sub_40C920(v1);\n  return sub_44BE20(&quot;re3&quot;, 511LL);\n&#125;\n\n发现它是在写一个re3的文件，而unk_4BC380这个地址含有明显的elf文件头，后面的dword_4C2070为长度：0x5cf0\n\n那么我们把这个re3提出来\nimport idc\nstart_addr &#x3D; 0x4BC380\nend_addr &#x3D; start_addr + 0x5cf0\nf &#x3D; open(&quot;re3&quot;,&quot;wb&quot;)\nfor addr in range(startaddr, endaddr):\n    f.write(idc.get_wide_byte(addr).to_bytes(1, &#39;little&#39;))\nf.close()\n\n得到的re3也是一个64位elf文件，同样放进ida64中，main函数如下\n\n先试一下按c转换成代码，再按p创建函数，成功得到主函数\n__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  struct __jmp_buf_tag env[1]; &#x2F;&#x2F; [rsp+10h] [rbp-850h] BYREF\n  struct __jmp_buf_tag v5[1]; &#x2F;&#x2F; [rsp+E0h] [rbp-780h] BYREF\n  struct __jmp_buf_tag v6[1]; &#x2F;&#x2F; [rsp+1B0h] [rbp-6B0h] BYREF\n  struct __jmp_buf_tag v7[1]; &#x2F;&#x2F; [rsp+280h] [rbp-5E0h] BYREF\n  char v8[640]; &#x2F;&#x2F; [rsp+350h] [rbp-510h] BYREF\n  char v9[636]; &#x2F;&#x2F; [rsp+5D0h] [rbp-290h] BYREF\n  int v10; &#x2F;&#x2F; [rsp+84Ch] [rbp-14h]\n  int v11; &#x2F;&#x2F; [rsp+850h] [rbp-10h]\n  int v12; &#x2F;&#x2F; [rsp+854h] [rbp-Ch]\n  int v13; &#x2F;&#x2F; [rsp+858h] [rbp-8h]\n  int v14; &#x2F;&#x2F; [rsp+85Ch] [rbp-4h]\n  __int64 savedregs; &#x2F;&#x2F; [rsp+860h] [rbp+0h] BYREF\n\n  v14 &#x3D; 1;\n  if ( a1 !&#x3D; 2 )\n    return 0LL;\n  sub_2490(a2[1]);\n  ((void (__fastcall *)(_BYTE *, char *, char *))loc_21F9)(byte_55C0, v9, v8);\n  v13 &#x3D; _setjmp(env);\n  if ( v13 &lt;&#x3D; 24 )\n  &#123;\n    v11 &#x3D; _setjmp(v5);\n    if ( v11 &lt; byte_50A0[25 * v13] )\n    &#123;\n      if ( byte_50A0[25 * v13 + 1 + v11] !&#x3D; *((char *)&amp;savedregs + 25 * v13 + v11 - 655) )\n        v14 &#x3D; 0;\n      longjmp(v5, v11 + 1);\n    &#125;\n    longjmp(env, v13 + 1);\n  &#125;\n  v12 &#x3D; _setjmp(v6);\n  if ( v12 &lt;&#x3D; 24 )\n  &#123;\n    v10 &#x3D; _setjmp(v7);\n    if ( v10 &lt; byte_5320[25 * v12] )\n    &#123;\n      if ( byte_5320[25 * v12 + 1 + v10] !&#x3D; *((char *)&amp;savedregs + 25 * v12 + v10 - 1295) )\n        v14 &#x3D; 0;\n      longjmp(v7, v10 + 1);\n    &#125;\n    longjmp(v6, v12 + 1);\n  &#125;\n  if ( v14 &#x3D;&#x3D; 1 )\n    puts(&quot;GOOD JOB&quot;);\n  return 0LL;\n&#125;\n\n两个二维数组byte_50A0和byte_5320\n提出来发现是个25*25的数织游戏\n结合之前的提示，解出来这个游戏应该就能拿到flag\nhttps://handsomeone.github.io/Nonogram/\n通过这个在线网站解出答案\n\nemmm，被坑了，不对，回到ida，用分析主函数的方法又分析到几个可疑的函数\nchar *sub_265C()\n&#123;\n  unsigned int v0; &#x2F;&#x2F; eax\n  char *result; &#x2F;&#x2F; rax\n  char v2[639]; &#x2F;&#x2F; [rsp+0h] [rbp-300h] BYREF\n  char needle[2]; &#x2F;&#x2F; [rsp+27Fh] [rbp-81h] BYREF\n  char v4; &#x2F;&#x2F; [rsp+281h] [rbp-7Fh]\n  char v5[4]; &#x2F;&#x2F; [rsp+282h] [rbp-7Eh] BYREF\n  __int16 v6; &#x2F;&#x2F; [rsp+286h] [rbp-7Ah]\n  char v7[4]; &#x2F;&#x2F; [rsp+288h] [rbp-78h] BYREF\n  __int16 v8; &#x2F;&#x2F; [rsp+28Ch] [rbp-74h]\n  char v9[2]; &#x2F;&#x2F; [rsp+28Eh] [rbp-72h] BYREF\n  char v10; &#x2F;&#x2F; [rsp+290h] [rbp-70h]\n  char format[8]; &#x2F;&#x2F; [rsp+291h] [rbp-6Fh] BYREF\n  int v12; &#x2F;&#x2F; [rsp+299h] [rbp-67h]\n  __int16 v13; &#x2F;&#x2F; [rsp+29Dh] [rbp-63h]\n  char v14; &#x2F;&#x2F; [rsp+29Fh] [rbp-61h]\n  char haystack[16]; &#x2F;&#x2F; [rsp+2A0h] [rbp-60h] BYREF\n  char s[32]; &#x2F;&#x2F; [rsp+2B0h] [rbp-50h] BYREF\n  __int64 v17; &#x2F;&#x2F; [rsp+2D0h] [rbp-30h]\n  int v18; &#x2F;&#x2F; [rsp+2DCh] [rbp-24h]\n  FILE *stream; &#x2F;&#x2F; [rsp+2E0h] [rbp-20h]\n  int n; &#x2F;&#x2F; [rsp+2E8h] [rbp-18h]\n  int m; &#x2F;&#x2F; [rsp+2ECh] [rbp-14h]\n  int l; &#x2F;&#x2F; [rsp+2F0h] [rbp-10h]\n  int k; &#x2F;&#x2F; [rsp+2F4h] [rbp-Ch]\n  int j; &#x2F;&#x2F; [rsp+2F8h] [rbp-8h]\n  int i; &#x2F;&#x2F; [rsp+2FCh] [rbp-4h]\n\n  *(_QWORD *)format &#x3D; 0xEAABA1EDE1FCFEA1LL;\n  v12 &#x3D; -268763743;\n  v13 &#x3D; -1030;\n  v14 &#x3D; -3;\n  *(_WORD *)v9 &#x3D; -5399;\n  v10 &#x3D; -20;\n  *(_DWORD *)v7 &#x3D; -268633374;\n  v8 &#x3D; -5139;\n  *(_DWORD *)v5 &#x3D; -268633347;\n  v6 &#x3D; -5139;\n  *(_WORD *)needle &#x3D; -5401;\n  v4 &#x3D; -17;\n  for ( i &#x3D; 0; i &lt;&#x3D; 14; ++i )\n    format[i] ^&#x3D; 0x8Eu;\n  for ( j &#x3D; 0; j &lt;&#x3D; 2; ++j )\n    v9[j] ^&#x3D; 0x8Eu;\n  for ( k &#x3D; 0; k &lt;&#x3D; 5; ++k )\n    v7[k] ^&#x3D; 0x8Eu;\n  for ( l &#x3D; 0; l &lt;&#x3D; 5; ++l )\n    v5[l] ^&#x3D; 0x8Eu;\n  for ( m &#x3D; 0; m &lt;&#x3D; 5; ++m )\n    needle[m] ^&#x3D; 0x8Eu;\n  v0 &#x3D; getppid();\n  snprintf(s, 0x1EuLL, format, v0);\n  stream &#x3D; fopen(s, &quot;r&quot;);\n  fgets(haystack, 16, stream);\n  fclose(stream);\n  result &#x3D; (char *)(strstr(haystack, needle) || strstr(haystack, v9) || strstr(haystack, v7) || strstr(haystack, v5));\n  v18 &#x3D; (int)result;\n  if ( !(_DWORD)result )\n  &#123;\n    qmemcpy(v2, &amp;unk_32A0, 0x271uLL);\n    result &#x3D; (char *)&amp;unk_5834 - 1940;\n    v17 &#x3D; (__int64)&amp;unk_5834 - 1940;\n    for ( n &#x3D; 0; n &lt;&#x3D; 24; ++n )\n      result &#x3D; (char *)memcpy((void *)(25 * n + v17), &amp;v2[25 * n], (unsigned __int8)v2[25 * n] + 1);\n  &#125;\n  return result;\n&#125;\n\n\n__int64 sub_257D()\n&#123;\n  char v1[640]; &#x2F;&#x2F; [rsp+0h] [rbp-290h] BYREF\n  __int64 v2; &#x2F;&#x2F; [rsp+280h] [rbp-10h]\n  int i; &#x2F;&#x2F; [rsp+28Ch] [rbp-4h]\n\n  qmemcpy(v1, &amp;unk_3020, 0x271uLL);\n  v2 &#x3D; (__int64)&amp;unk_5838 - 1304;\n  for ( i &#x3D; 0; i &lt;&#x3D; 24; ++i )\n    memcpy((void *)(25 * i + v2), &amp;v1[25 * i], (unsigned __int8)v1[25 * i] + 1);\n  return nullsub_2();\n&#125;\n\nsub_265C里面的&amp;unk_32A0和sub_257D里面的&amp;unk_3020也是25*25的二维数组非常可疑\n提出来当作数织的行和列再解一遍\n\n嗯，对味\nFLAG&#123;I LOVE PLAY ctf_QWB2022&#125;","slug":"20220803-hws-qwb-recurrent","date":"2022-08-03T03:00:00.000Z","categories_index":"Write Up","tags_index":"ctf,wp,reverse","author_index":"y9nhjy"},{"id":"ebb392945466e3b28411a4ab0abfa6f9","title":"2022-HWS夏令营预选赛","content":"2022-HWS夏令营预选赛\n比赛：HWS计划第五期-2022硬件安全在线夏令营线上预选赛\n时间：2022-07-29 09:00:00~2022-08-01 21:00:00\nReverse\n​\tre1\nCrypto\n​\teasyRSA\nMsic\n​\trandom\n硬件(Crypto侧信道)\n​\tRead&amp;Slove\nReversere1拖进ida进入主程序：\n进入加密函数看一看，嗯，一眼xxtea加密\n\n拿到密文：\n473bbd10f9e05561c5ebf76a5f43238d0516091aef403dd4676ab1b4a978356b\n\n获取密钥：\n34120000452300006745000089670000\n\n脚本解密：\nimport xxtea\n\ns &#x3D; 0x473bbd10f9e05561c5ebf76a5f43238d0516091aef403dd4676ab1b4a978356b.to_bytes(32, &#39;big&#39;)\nkey &#x3D; 0x34120000452300006745000089670000.to_bytes(16, &#39;big&#39;)\nflag &#x3D; xxtea.decrypt(s, key, padding&#x3D;False)\nprint(flag)\n\n\n\n\n\n\n\n\n\n\n7f943921724d63dc0ac9c6febf99fa88\nCryptoeasyRSA已知:\n\n解方程:\na * seed + b &#x3D; s1 (mod p)\n\na * s1 + b &#x3D; s2 (mod p)\n\na * s2 + b &#x3D; s3 (mod p)\n\n解得seed=14337636555117933152506165016723944787939761429733562849369091223517166614830298165864272285381681301117\n最后直接long_to_bytes(seed)\n\n\n\n\n\n\n\n\n\ne4syRsa1snotdifficult5996642D0A7415EF\nMsicrandom先根据图片的像素通道值将原本的r3数组还原，再模拟原本打乱的顺序，将其还原后得到flag\nexp:\nimport random\nfrom PIL import Image\n\ndef pbl(bits):\n  num &#x3D; random.getrandbits(bits)\n  bins &#x3D; []\n  while num:\n    bins.append(num &amp; 1)\n    num &gt;&gt;&#x3D; 1\n  while len(bins) !&#x3D; bits:\n    bins.append(0)\n  return bins\n \nr3 &#x3D; []\nxx &#x3D; Image.open(&#39;xx.png&#39;)\ncat &#x3D; Image.open(&#39;1.png&#39;)\nfor i in range(198):\n  for j in range(141):\n    r3.append(xx.getpixel((i, j))[2] ^ cat.getpixel((i, j))[2])\n\norder &#x3D; []\nfor i in range(27918):\n  order.append(i)\n\nrandom.seed(793211)\npbl(27918)\npbl(27918)\nrandom.getrandbits((27918 - 28) * 8)\nrandom.shuffle(order)\n\nflag &#x3D; []\nfor i in range(28):\n  for j in range(len(order)):\n    if order[j] &#x3D;&#x3D; i:\n      flag.append(r3[j])\n\nfor i in flag:\n  print(chr(i), end&#x3D;&#39;&#39;)\n\n\n\n\n\n\n\n\n\n\nflag{lovely_cat_with_random}\n硬件(Crypto侧信道)Read&amp;Slove\n将波形翻译为二进制即1010 1101 0010 1100\n再根据公告说换成hex:ad2c\n","slug":"20220801-hws-qualifier","date":"2022-08-01T03:00:00.000Z","categories_index":"Write Up","tags_index":"ctf,wp,reverse","author_index":"y9nhjy"}]