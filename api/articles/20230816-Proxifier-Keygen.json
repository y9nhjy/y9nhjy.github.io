{"title":"Proxifier注册机","uid":"f4299006905b671658e489a5612f0ab4","slug":"20230816-Proxifier-Keygen","date":"2023-08-16T03:00:00.000Z","updated":"2023-08-16T10:26:16.962Z","comments":true,"path":"api/articles/20230816-Proxifier-Keygen.json","keywords":null,"cover":[],"content":"<h1 id=\"Declaration\"><a href=\"#Declaration\" class=\"headerlink\" title=\"Declaration\"></a>Declaration</h1><p>本项目仅用作学习教育目的, 不用于任何其他用途, 如有侵权请第一时间联系作者删除</p>\n<p>This project is only for learning and educational purposes and is not intended for any other purpose. If there is any infringement, please contact the author immediately to delete it</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>软件官网<a href=\"https://www.proxifier.com/\">Proxifier - The Most Advanced Proxy Client</a></p>\n<p>这里下载的是安装版(setup)</p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230816131222485.png\" alt=\"image-20230816131222485\"></p>\n<p>一路next下去安装完毕即可</p>\n<h1 id=\"正向\"><a href=\"#正向\" class=\"headerlink\" title=\"正向\"></a>正向</h1><h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>启动Proxifier点击Registration Key</p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230816131258954.png\" alt=\"image-20230816131258954\"></p>\n<p>随便输入会提示Key格式不对, 为<code>xxxxx-xxxxx-xxxxx-xxxxx-xxxxx</code>, 为方便描述, 本文将每5个字符称为1组, 下文也会提到。然后照着格式再次随便输入查看Key错误时的反馈</p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230808113527603.png\" alt=\"image-20230808113527603\"></p>\n<p>接下来, IDA, 启动！搜索字符串<code>The registration Key is incorrect.</code></p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230816162850059.png\" alt=\"image-20230816162850059\"></p>\n<p>定位至此处</p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230808113322050.png\" alt=\"image-20230808113322050\"></p>\n<p>通过交叉引用定位关键Check函数</p>\n<p><img src=\"20230816-Proxifier-Keygen/image-20230816163111716.png\" alt=\"image-20230816163111716\"></p>\n<h2 id=\"Check算法\"><a href=\"#Check算法\" class=\"headerlink\" title=\"Check算法\"></a>Check算法</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">char __fastcall Check(unsigned int *a1, _QWORD *a2, __int64 a3)\n&#123;\n  _QWORD *v4; &#x2F;&#x2F; rsi\n  const wchar_t *v6; &#x2F;&#x2F; rdx\n  _QWORD *v8; &#x2F;&#x2F; r8\n  _QWORD *v9; &#x2F;&#x2F; r8\n  _QWORD *v10; &#x2F;&#x2F; r8\n  _QWORD *v11; &#x2F;&#x2F; r8\n  _QWORD *v12; &#x2F;&#x2F; rax\n  __int16 v13; &#x2F;&#x2F; dx\n  _QWORD *v14; &#x2F;&#x2F; rax\n  __int64 v15; &#x2F;&#x2F; rax\n  __int64 v16; &#x2F;&#x2F; rcx\n  int v17; &#x2F;&#x2F; edi\n  int v18; &#x2F;&#x2F; ebx\n  __int64 v19; &#x2F;&#x2F; rax\n  __int64 v20; &#x2F;&#x2F; rcx\n  __int64 v21; &#x2F;&#x2F; rax\n  __int64 v22; &#x2F;&#x2F; rcx\n  int v23; &#x2F;&#x2F; er15\n  __int64 v24; &#x2F;&#x2F; rax\n  unsigned int v25; &#x2F;&#x2F; er15\n  __int64 v26; &#x2F;&#x2F; rcx\n  int v27; &#x2F;&#x2F; eax\n  unsigned int v28; &#x2F;&#x2F; er10\n  unsigned int v29; &#x2F;&#x2F; ecx\n  char v30[32]; &#x2F;&#x2F; [rsp+20h] [rbp-78h] BYREF\n  __int64 v31; &#x2F;&#x2F; [rsp+40h] [rbp-58h]\n  _QWORD *v32; &#x2F;&#x2F; [rsp+48h] [rbp-50h]\n  int v33[4]; &#x2F;&#x2F; [rsp+50h] [rbp-48h] BYREF\n\n  v31 &#x3D; -2i64;\n  v4 &#x3D; a2;\n  v32 &#x3D; a2;\n  if ( a2[2] !&#x3D; 29i64 )\n  &#123;\n    v6 &#x3D; L&quot;Incorrect Key length.&quot;;\nLABEL_3:\n    sub_140003550(a3, v6);\n    unknown_libname_3(v4);\n    return 0;\n  &#125;\n  v8 &#x3D; a2;\n  if ( a2[3] &gt;&#x3D; 8ui64 )\n    v8 &#x3D; (_QWORD *)*a2;\n  sub_1400034B0(a2, v33, (char *)v8 + 46);   &#x2F;&#x2F; 函数作用:去掉&#39;-&#39;\n  v9 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v9 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v9 + 34);\n  v10 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v10 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v10 + 22);\n  v11 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v11 &#x3D; (_QWORD *)*v4;\n  sub_1400034B0(v4, v33, (char *)v11 + 10);   &#x2F;&#x2F; 最终得到&#39;XXXXXXXXXXXXXXXXXXXXXXXXX&#39;\n  v12 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v12 &#x3D; (_QWORD *)*v4;\n  v13 &#x3D; *((_WORD *)v12 + 14);                 &#x2F;&#x2F; 取第3组第5个字符 &#39;4&#39;\n  v14 &#x3D; v4;\n  if ( v4[3] &gt;&#x3D; 8ui64 )\n    v14 &#x3D; (_QWORD *)*v4;\n  *((_WORD *)v14 + 2) &#x3D; v13;                  &#x2F;&#x2F; 第1组第3个字符赋值为第3组第5个字符, 即此字符不影响Key\n  v15 &#x3D; sub_1400037E0(v4, v30, 20i64);        &#x2F;&#x2F; 取第5组字符\n  v17 &#x3D; sub_1400031A0(v16, v15);              &#x2F;&#x2F; 第一个参数:v15一个字符的ascii值\n                                              &#x2F;&#x2F; 此函数的作用:将字符串转换为数字, 本函数可逆\n  v18 &#x3D; v17 ^ (v17 &lt;&lt; 7);\n  v19 &#x3D; sub_1400037E0(v4, v30, 15i64);        &#x2F;&#x2F; 取第4组字符\n  a1[7] &#x3D; sub_1400031A0(v20, v19);\n  v21 &#x3D; sub_1400037E0(v4, v30, 0i64);         &#x2F;&#x2F; 取整个Key的前7个字符\n  v23 &#x3D; sub_1400031A0(v22, v21);\n  v24 &#x3D; sub_1400037E0(v4, v30, 7i64);         &#x2F;&#x2F; 取整个Key的第8-14个字符\n  v25 &#x3D; v18 ^ v23 ^ 0x12345678;               &#x2F;&#x2F; v33的低4字节\n  v27 &#x3D; sub_1400031A0(v26, v24);\n  v33[0] &#x3D; v25;\n  v33[1] &#x3D; v18 ^ v27 ^ 0x87654321;            &#x2F;&#x2F; v33的中4字节\n  v33[2] &#x3D; a1[7];                             &#x2F;&#x2F; v33的高4字节\n  if ( v17 !&#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF) )  &#x2F;&#x2F; 此函数类似CRC32, 目测不可逆\n  &#123;\n    v6 &#x3D; L&quot;Incorrect Key&quot;;\n    goto LABEL_3;\n  &#125;\n  *a1 &#x3D; v25 &gt;&gt; 21;\n  a1[1] &#x3D; HIWORD(v25) &amp; 0x1F;\n  a1[2] &#x3D; (unsigned __int16)v25 &gt;&gt; 5;\n  a1[3] &#x3D; v25 &amp; 0x1F;\n  v29 &#x3D; HIWORD(v28);\n  a1[6] &#x3D; (unsigned __int16)v28;\n  if ( HIWORD(v28) )\n  &#123;\n    a1[4] &#x3D; v29 &#x2F; 0xC + 2000;\n    a1[5] &#x3D; v29 % 0xC;\n  &#125;\n  else\n  &#123;\n    *((_QWORD *)a1 + 2) &#x3D; 0i64;\n  &#125;\n  unknown_libname_3(v4);\n  return 1;\n&#125;</code></pre>\n\n<p>前面会检查Key的长度是否为29, 即<code>XXXXX-XXXXX-XXXXX-XXXXX-XXXXX</code>的长度</p>\n<p>然后主要需要分析<code>sub_1400034B0, sub_1400037E0, sub_1400031A0, sub_140003260</code>这4个函数的功能</p>\n<ul>\n<li><p>本地调试直接步过看Key的变化, 很容易就能看出<code>sub_1400034B0</code>的功能, 即去掉 ‘-‘</p>\n</li>\n<li><p><code>sub_1400037E0</code>, 同样的办法可以看出此函数是取出Key的部分字符</p>\n</li>\n<li><p>然后就是<code>sub_1400031A0</code>, 进去看看</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__int64 __fastcall sub_1400031A0(__int64 a1, __int64 a2)\n&#123;\n  unsigned int v2; &#x2F;&#x2F; ebx\n  int v3; &#x2F;&#x2F; eax\n  __int64 i; &#x2F;&#x2F; r8\n  __int64 v5; &#x2F;&#x2F; rax\n  unsigned __int16 v6; &#x2F;&#x2F; ax\n\n  v2 &#x3D; 0;\n  v3 &#x3D; *(_DWORD *)(a2 + 16) - 1;\n  for ( i &#x3D; v3; i &gt;&#x3D; 0; --i )\n  &#123;\n    v2 *&#x3D; 32;\n    v5 &#x3D; a2;\n    if ( *(_QWORD *)(a2 + 24) &gt;&#x3D; 8ui64 )\n      v5 &#x3D; *(_QWORD *)a2;\n    v6 &#x3D; *(_WORD *)(v5 + 2 * i);\n    switch ( v6 )\n    &#123;\n      case &#39;W&#39;:\n        continue;\n      case &#39;X&#39;:\n        v6 &#x3D; 79;\n        break;\n      case &#39;Y&#39;:\n        v2 &#x3D; v2 - 48 + 49;\n        continue;\n      case &#39;Z&#39;:\n        v6 &#x3D; 73;\n        break;\n      default:\n        if ( (unsigned __int16)(v6 - 48) &lt;&#x3D; 9u )\n        &#123;\n          v2 &#x3D; v6 + v2 - 48;\n          continue;\n        &#125;\n        break;\n    &#125;\n    v2 &#x3D; v6 + v2 - 55;\n  &#125;\n  unknown_libname_3(a2);\n  return v2;\n&#125;</code></pre>\n\n<p>  可以自己跟着写一遍此算法, 主要作用：将字符串根据此算法转换为数字并返回, 此函数的python实现可以参考本人<a href=\"https://github.com/y9nhjy/Proxifier_Keygen\">y9nhjy&#x2F;Proxifier_Keygen </a>项目中Proxifier_Checker.py里的handle函数</p>\n</li>\n<li><p><code>sub_140003260</code>：算法类似CRC32, 目测不可逆</p>\n</li>\n</ul>\n<p>最后总结Check完整逻辑：</p>\n<ul>\n<li>去除 ‘-‘</li>\n<li>将第1组第3个字符赋值为第3组第5个字符</li>\n<li>v17：第5组字符经过handle函数所生成的数字</li>\n<li>v18 &#x3D; v17 ^ (v17 &lt;&lt; 7)</li>\n<li>v23：取整个Key的前7个字符经过handle函数所生成的数字</li>\n<li>v27：取整个Key的第8-14个字符经过handle函数所生成的数字</li>\n<li>v33的低4字节：v18 ^ v23 ^ 0x12345678</li>\n<li>v33的中4字节：v18 ^ v27 ^ 0x87654321</li>\n<li>v33的高4字节：第4组字符经过handle函数所生成的数字</li>\n<li>最后比较 v17 !&#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF)</li>\n</ul>\n<h1 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h1><p>项目源代码：<a href=\"https://github.com/y9nhjy/Proxifier_Keygen\">y9nhjy&#x2F;Proxifier_Keygen </a>, 欢迎<strong>star</strong></p>\n<p>既然<code>sub_140003260</code>不可逆, 就考虑构造v33</p>\n<p>目前已知v33, 逆推Key的流程：</p>\n<ol>\n<li>根据高4字节逆推第4组字符</li>\n<li>根据v17 &#x3D; (sub_140003260(v33) &amp; 0x1FFFFFF)得到v17后可逆推第5组字符和得到v18</li>\n<li>v23 &#x3D; v33的低4字节 ^ v18 ^ 0x12345678, 然后逆推出Key的前7个字符</li>\n<li>v27 &#x3D; v33的中4字节 ^ v18 ^ 0x87654321, 然后逆推出Key的第8-14个字符</li>\n<li>Key的第15个字符即Key的第3个字符</li>\n<li>随机生成Key的第3个字符</li>\n<li>得到最终的Key</li>\n</ol>\n<p>注意事项：</p>\n<ol>\n<li>v33的1~2字节小于0x2580是过期的Key, 高两字节是产品版本, 为0则是安装版, 1是便携版, 2是Mac版</li>\n<li>v33的7~8字节是证书有效期, 为零直接无限期</li>\n<li>Key的第3位不影响Key, 但是不能为 ‘Y’, 否则版本对不上</li>\n</ol>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>断断续续调了几天, 将Check算法还原成功后, 参考了<a href=\"https://github.com/Danz17/Proxifier-Keygen\">Danz17&#x2F;Proxifier-Keygen</a>注册机的源代码, 学到了不少, 对其中的流程也更加清晰, 最终总算是实现了注册机的编写, 欢迎各位师傅给我的项目<strong>star</strong>, 传送门：<a href=\"https://github.com/y9nhjy/Proxifier_Keygen\">y9nhjy&#x2F;Proxifier_Keygen </a></p>\n<p>时隔满满一年终于更新了, 之前电脑出问题系统重装数据全没了, 包括博客, 血压拉满, 就一直没再折腾博客, 这次重新搭建博客, 更换了一个更酷炫的主题, 整体还是比较满意, 就这样吧。</p>\n","feature":true,"text":"Declaration本项目仅用作学习教育目的, 不用于任何其他用途, 如有侵权请第一时间联系作者删除 This project is only for lea...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"Keygen","slug":"Keygen","count":1,"path":"api/categories/Keygen.json"}],"tags":[{"name":"reverse","slug":"reverse","count":4,"path":"api/tags/reverse.json"},{"name":"Keygen","slug":"Keygen","count":1,"path":"api/tags/Keygen.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Declaration\"><span class=\"toc-text\">Declaration</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">安装</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%90%91\"><span class=\"toc-text\">正向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">开始</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Check%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Check算法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%86%E5%90%91\"><span class=\"toc-text\">逆向</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A2%8E%E7%A2%8E%E5%BF%B5\"><span class=\"toc-text\">碎碎念</span></a></li></ol>","author":{"name":"y9nhjy","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/73747088?v=4","link":"https://y9nhjy.github.io","description":"手握日月摘星辰","socials":{"github":"https://github.com/y9nhjy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_51280668","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"2022-HWS夏令营线下赛","uid":"63c1d1c611bd361be9cbbdc1ef690d2f","slug":"20220815-hws-live","date":"2022-08-15T03:00:00.000Z","updated":"2023-08-16T10:22:17.854Z","comments":true,"path":"api/articles/20220815-hws-live.json","keywords":null,"cover":[],"text":"2022-HWS夏令营线下赛 比赛：HWS计划第五期-2022硬件安全在线夏令营线下赛 时间：2022-08-15 17:00:00~2022-08-01 22...","link":"","photos":[],"count_time":{"symbolsCount":286,"symbolsTime":"1 mins."},"categories":[{"name":"Write Up","slug":"Write-Up","count":3,"path":"api/categories/Write-Up.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"},{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"},{"name":"reverse","slug":"reverse","count":4,"path":"api/tags/reverse.json"}],"author":{"name":"y9nhjy","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/73747088?v=4","link":"https://y9nhjy.github.io","description":"手握日月摘星辰","socials":{"github":"https://github.com/y9nhjy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_51280668","juejin":"","customs":{}}},"feature":true}}