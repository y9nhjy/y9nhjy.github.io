{"title":"2022-HWS&强网杯-复现","uid":"5bb046c422c129abba05bb14d8709ec6","slug":"20220803-hws-qwb-recurrent","date":"2022-08-03T03:00:00.000Z","updated":"2023-08-16T10:28:21.257Z","comments":true,"path":"api/articles/20220803-hws-qwb-recurrent.json","keywords":null,"cover":[],"content":"<p><strong>2022-HWS&amp;强网杯-复现</strong></p>\n<p><a href=\"#HWS\">HWS</a></p>\n<p>​\t<a href=\"#re2\">re2</a></p>\n<p>​\t<a href=\"#re3\">re3</a></p>\n<p><a href=\"#%E5%BC%BA%E7%BD%91%E6%9D%AF\">强网杯</a></p>\n<p>​\t<a href=\"#GameMaster\">GameMaster</a></p>\n<p>​\t<a href=\"#easyre\">easyre</a></p>\n<h1 id=\"HWS\"><a href=\"#HWS\" class=\"headerlink\" title=\"HWS\"></a>HWS</h1><h2 id=\"re2\"><a href=\"#re2\" class=\"headerlink\" title=\"re2\"></a>re2</h2><p>拿到源文件re2.exe，放进ida32里，反编译主函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int __cdecl main(int argc, const char **argv, const char **envp)\n&#123;\n  char v3; &#x2F;&#x2F; bl\n  char v4; &#x2F;&#x2F; al\n  int v5; &#x2F;&#x2F; ecx\n  struct _EXCEPTION_REGISTRATION_RECORD *v7; &#x2F;&#x2F; [esp+0h] [ebp-18h]\n  void *v8; &#x2F;&#x2F; [esp+4h] [ebp-14h]\n\n  v8 &#x3D; &amp;loc_401450;\n  v7 &#x3D; NtCurrentTeb()-&gt;NtTib.ExceptionList;\n  v3 &#x3D; 0;\n  do\n  &#123;\n    v4 &#x3D; sub_40491D(v7, v8);\n    v5 &#x3D; v3++;\n    byte_41B2EC[v5] &#x3D; v4;\n  &#125;\n  while ( v4 !&#x3D; 10 );\n  byte_41B2EC[v3] &#x3D; 0;\n  dword_41B2E8 &#x3D; (char)(v3 - 1);\n  __debugbreak();\n  __debugbreak();\n  __debugbreak();\n  return 0;\n&#125;</code></pre>\n\n<p>暂时看不出来什么，惯例打开字符串窗口查一查</p>\n<p>发现两条可疑的字符串</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803145046452.png\" alt=\"image-20220803145046452\"></p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803145103011.png\" alt=\"image-20220803145103011\"></p>\n<p>这两条字符串都指向同一个函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">intptr_t sub_4013D0()\n&#123;\n  int i; &#x2F;&#x2F; [esp+Ch] [ebp-4h]\n\n  for ( i &#x3D; 0; byte_41B2EC[i] &amp;&amp; i &lt;&#x3D; 8; ++i )\n  &#123;\n    if ( (i ^ byte_41B2EC[i]) !&#x3D; byte_41A8B4[i] )\n      goto LABEL_7;\n  &#125;\n  sub_401010((int)off_41A8B0);\n  _loaddll(0);\nLABEL_7:\n  sub_401010((int)&quot;wrong\\n&quot;);\n  return _loaddll(0);\n&#125;</code></pre>\n\n<p>接下来就很简单了，根据逻辑写exp</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">a &#x3D; [0x46, 0x40, 0x49, 0x46, 0x7F, 0x52, 0x6E, 0x46, 0x7C, 0x24, 0x6B, 0x26, 0x5C, 0x64, 0x7A, 0x5B, 0x49, 0x6C]\nfor i in range(len(a)):\n    print(chr(a[i] ^ i), end&#x3D;&#39;&#39;)</code></pre>\n\n<p><code>FAKE&#123;WhAt-a-PitTY&#125;</code></p>\n<p>真的{很好} (痴呆🤤)</p>\n<p>从头再来</p>\n<p>根据这位师傅的wp</p>\n<p><a href=\"https://blog.csdn.net/weixin_45582916/article/details/126050524\">REVERSE-COMPETITION-HWS-5TH-2022</a></p>\n<p>发现了Tls函数，第一次知道这个函数，了解了一下，以后需要多注意此类型函数</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">代码逆向分析领域中，TLS（Thread Local Storage，线程局部存储）回调函数（Callback Function）常用反调试。TLS回调函数的调用运行要先于EP代码的执行，该特征使它可以作为一种反调试技术的使用。\nTLS是各线程的独立的数据存储空间，使用TLS技术可在线程内部独立使用或修改进程的全局数据或静态数据，就像对待自身的局部变量一样。</code></pre>\n\n<p>接着分析此函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void __stdcall TlsCallback_0(int a1, DWORD flOldProtect, int a3)\n&#123;\n  int i; &#x2F;&#x2F; eax\n\n  if ( flOldProtect &#x3D;&#x3D; 1 )\n  &#123;\n    VirtualProtect(StartAddress, 0x320u, 0x40u, &amp;flOldProtect);\n    for ( i &#x3D; 0; i &lt; 800; ++i )\n      *((_BYTE *)StartAddress + i) ^&#x3D; i;\n    CreateThread(0, 0, StartAddress, 0, 0, 0);\n  &#125;\n&#125;</code></pre>\n\n<p>这是一段SMC，明显特征为<strong>将一段数组作为函数调用</strong></p>\n<p>先将这段代码还原</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import idc\nstart_addr &#x3D; 0x401040\nend_addr &#x3D; start_addr + 800\nfor addr in range(start_addr, end_addr):\n    i &#x3D; addr - start_addr\n    by &#x3D; idc.get_wide_byte(addr)\n    ida_bytes.patch_byte(addr, by ^ i)</code></pre>\n\n<p>还原后还有少部分代码ida没有分析到位，找到那些地方按c分析代码</p>\n<p>分析完毕之后再选中StaatAddress这一大段代码，按p创建函数，这样就可以反编译了</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">DWORD __stdcall StartAddress(LPVOID lpThreadParameter)\n&#123;\n  int k; &#x2F;&#x2F; ebx\n  int v4; &#x2F;&#x2F; [esp-Ch] [ebp-50548h]\n  int v5; &#x2F;&#x2F; [esp-8h] [ebp-50544h]\n  int v6[65534]; &#x2F;&#x2F; [esp+Ch] [ebp-50530h]\n  char v7[66816]; &#x2F;&#x2F; [esp+40004h] [ebp-10538h] BYREF\n  int v8[6]; &#x2F;&#x2F; [esp+50504h] [ebp-38h]\n  char *v9; &#x2F;&#x2F; [esp+5051Ch] [ebp-20h]\n  int v10; &#x2F;&#x2F; [esp+50520h] [ebp-1Ch]\n  int v11; &#x2F;&#x2F; [esp+50524h] [ebp-18h]\n  int v12; &#x2F;&#x2F; [esp+50528h] [ebp-14h]\n  int v13; &#x2F;&#x2F; [esp+5052Ch] [ebp-10h]\n  int i; &#x2F;&#x2F; [esp+50530h] [ebp-Ch]\n  int v15; &#x2F;&#x2F; [esp+50534h] [ebp-8h]\n  int j; &#x2F;&#x2F; [esp+50538h] [ebp-4h]\n\n  while ( !dword_41B2E4 )\n    Sleep(0x3E8u);\n  for ( i &#x3D; 0; i &lt; 112; ++i )\n    byte_41B30A +&#x3D; *((_BYTE *)sub_401450 + i);\n  for ( i &#x3D; 0; input[i]; ++i )\n    input[i] ^&#x3D; byte_41B30A;\n  v8[0] &#x3D; &#39;Q&#39;;\n  v8[1] &#x3D; &#39;f&#39;;\n  v8[2] &#x3D; &#39;r&#39;;\n  v8[3] &#x3D; &#39;o&#39;;\n  v8[4] &#x3D; &#39;s&#39;;\n  v8[5] &#x3D; &#39;t&#39;;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; j;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n    v7[j + 0x10000] &#x3D; v8[j % 6];\n  v15 &#x3D; 0;\n  for ( j &#x3D; 0; j &lt; 256; ++j )\n  &#123;\n    v15 &#x3D; (v7[j + 0x10000] + *(_DWORD *)&amp;v7[4 * j + 65792] + v15) % 256;\n    v12 &#x3D; *(_DWORD *)&amp;v7[4 * j + 65792];\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; *(_DWORD *)&amp;v7[4 * v15 + 65792];\n    *(_DWORD *)&amp;v7[4 * v15 + 65792] &#x3D; v12;\n  &#125;\n  v13 &#x3D; dword_41B2E8;\n  v11 &#x3D; 0;\n  v15 &#x3D; 0;\n  j &#x3D; 0;\n  while ( v13-- )\n  &#123;\n    j &#x3D; (j + 1) % 256;\n    v15 &#x3D; (*(_DWORD *)&amp;v7[4 * j + 65792] + v15) % 256;\n    v12 &#x3D; *(_DWORD *)&amp;v7[4 * j + 65792];\n    *(_DWORD *)&amp;v7[4 * j + 65792] &#x3D; *(_DWORD *)&amp;v7[4 * v15 + 65792];\n    *(_DWORD *)&amp;v7[4 * v15 + 65792] &#x3D; v12;\n    v10 &#x3D; (*(_DWORD *)&amp;v7[4 * v15 + 65792] + *(_DWORD *)&amp;v7[4 * j + 65792]) % 256;\n    v6[v11++] &#x3D; *(_DWORD *)&amp;v7[4 * v10 + 65792];\n  &#125;\n  for ( j &#x3D; 0; j &lt; dword_41B2E8; ++j )\n    v7[j] &#x3D; LOBYTE(v6[j]) ^ input[j];\n  v9 &#x3D; v7;\n  for ( k &#x3D; 0; k &lt; dword_41B2E8; ++k )\n  &#123;\n    if ( v9[k] !&#x3D; *(_BYTE *)(k + 0x401307) )\n    &#123;\n      sub_401010(4199237);\n      _loaddll(0);\n      break;\n    &#125;\n  &#125;\n  sub_401010((int)&quot;right\\n&quot;);\n  getchar(v4, v5);\n  return 0;\n&#125;</code></pre>\n\n<p>此处先将input(也就是flag)与byte_41B30A异或，然后对input进行RC4加密，密钥为<code>Qfrost</code></p>\n<p>根据逻辑求出byte_41B30A</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import idc\nstart_addr &#x3D; 0x401450\nend_addr &#x3D; start_addr + 112\nbyte_41B30A &#x3D; 0\nfor addr in range(start_addr, end_addr):\n    byte_41B30A +&#x3D; idc.get_wide_byte(addr)\nprint(hex(byte_41B30A &amp; 0xff))\n0x48</code></pre>\n\n<p>根据最后判断的地方0x401307拿到密文</p>\n<p>借用师傅的脚本</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;stdio.h&gt;\n\n&#x2F;&#x2F;RC4初始化函数\nvoid rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123;\n\tunsigned int i &#x3D; 0, j &#x3D; 0;\n\tchar k[256] &#x3D; &#123; 0 &#125;;\n\tunsigned char tmp &#x3D; 0;\n\tfor (i &#x3D; 0; i &lt; 256; i++) &#123;\n\t\ts[i] &#x3D; i;\n\t\tk[i] &#x3D; key[i % Len_k];\n\t&#125;\n\tfor (i &#x3D; 0; i &lt; 256; i++) &#123;\n\t\tj &#x3D; (j + s[i] + k[i]) % 256;\n\t\ttmp &#x3D; s[i];\n\t\ts[i] &#x3D; s[j];\n\t\ts[j] &#x3D; tmp;\n\t&#125;\n&#125;\n\n&#x2F;*\nRC4加解密函数\nunsigned char* Data     加解密的数据\nunsigned long Len_D     加解密数据的长度\nunsigned char* key      密钥\nunsigned long Len_k     密钥长度\n*&#x2F;\nvoid rc4_crypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k)&#123;\n\tunsigned char s[256];\n\trc4_init(s, key, Len_k);\n\tint i &#x3D; 0, j &#x3D; 0, t &#x3D; 0;\n\tunsigned long k &#x3D; 0;\n\tunsigned char tmp;\n\tfor (k &#x3D; 0; k &lt; Len_D; k++) &#123;\n\t\ti &#x3D; (i + 1) % 256;\n\t\tj &#x3D; (j + s[i]) % 256;\n\t\ttmp &#x3D; s[i];\n\t\ts[i] &#x3D; s[j];\n\t\ts[j] &#x3D; tmp;\n\t\tt &#x3D; (s[i] + s[j]) % 256;\n\t\tData[k] &#x3D; Data[k] ^ s[t];\n\t&#125;\n&#125;\n\nint main()&#123;\n\t&#x2F;&#x2F;字符串密钥\n\tunsigned char key[] &#x3D; &quot;Qfrost&quot;;\n\tunsigned long key_len &#x3D; sizeof(key) - 1;\n\t&#x2F;*\n\t&#x2F;&#x2F;数组密钥\n\tunsigned char key[] &#x3D; &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;;\n\tunsigned long key_len &#x3D; sizeof(key);\n    *&#x2F;\n\t&#x2F;&#x2F;加解密数据\n\tunsigned char data[] &#x3D; &#123;0x7F, 0xB6, 0x88, 0x12, 0xDC, 0xC3, 0xDE, 0xDB, 0x30, 0x24, \n    0xE3, 0xC1, 0x0F, 0xC9, 0x7F, 0xC2, 0x4D, 0x9C, 0x6B, 0x02, \n    0x26, 0x20, 0xF1, 0x25, 0xA0, 0xE3, 0xC6, 0xDE &#125;;\n\t&#x2F;&#x2F;加解密\n\trc4_crypt(data, sizeof(data), key, key_len);\n\n\tfor (int i &#x3D; 0; i &lt; sizeof(data); i++)&#123;\n\t\tprintf(&quot;%c&quot;, data[i] ^ 0x48);  &#x2F;&#x2F;0x48即byte_41B30A\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n<p><code>QDbg-Is_an_1ntereSting-Game!</code></p>\n<h2 id=\"re3\"><a href=\"#re3\" class=\"headerlink\" title=\"re3\"></a>re3</h2><p>拿到源文件ctf.apk，放进jadx中，找到MainActicity</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220809151021409.png\" alt=\"image-20220809151021409\"></p>\n<p>发现关键在于这个native check函数，用apktool反编译apk，进入lib目录，将里面的so文件放进ida</p>\n<p>容易找到关键函数：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool __fastcall sub_D060(int a1, int a2, int a3)\n&#123;\n  const char *v4; &#x2F;&#x2F; [sp+20h] [bp-490h]\n  size_t i; &#x2F;&#x2F; [sp+28h] [bp-488h]\n  size_t v9; &#x2F;&#x2F; [sp+7Ch] [bp-434h]\n  char v10[272]; &#x2F;&#x2F; [sp+80h] [bp-430h] BYREF\n  char v11[272]; &#x2F;&#x2F; [sp+190h] [bp-320h] BYREF\n  int v12[132]; &#x2F;&#x2F; [sp+2A0h] [bp-210h] BYREF\n\n  memset(v12, 0, 0x204u);\n  v12[0] &#x3D; 1024;\n  memset(v11, 0, sizeof(v11));\n  memset(v10, 0, sizeof(v10));\n  v4 &#x3D; (const char *)_JNIEnv::GetStringUTFChars(a1, a3, 0);\n  v9 &#x3D; strlen(v4);\n  if ( (unsigned __int8)v9 &lt;&lt; 31 || v9 &gt; 0x200 || v9 &lt;&#x3D; 0xF )\n    return 0;\n  for ( i &#x3D; 0; i &lt; v9 &gt;&gt; 1; ++i )\n  &#123;\n    v10[i] &#x3D; v4[2 * i] - 48;\n    if ( (unsigned __int8)v10[i] &gt;&#x3D; 0xAu )\n      v10[i] -&#x3D; 39;\n    v10[i] +&#x3D; 36 * v4[2 * i + 1] + 64;\n  &#125;\n  _memcpy_chk((char *)&amp;v12[38] + 3, &amp;unk_7721, 105, 361);\n  _memcpy_chk((char *)&amp;v12[128] + 1, &amp;unk_778A, 3, 3);\n  sub_2304(v11);\n  return strncmp(&amp;v11[108], sure_flag, 0x14u) &#x3D;&#x3D; 0;\n&#125;</code></pre>\n\n<p>for循环是转换36进制的字符串为16进制</p>\n<p>sub_31D0据wp说是RSA加密函数，ttttcl看不出来，n和e已知</p>\n<p>最后将得到的值和sure_flag作比较</p>\n<p>sure_flag:49 20 61 6D 20 73 75 72 65 20 69 74 20 69 73 20 66 6C 34 67 00</p>\n<p>借用exp</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import gmpy2\n\nn &#x3D; 0x7019325b70f4a2f26e921102a0206de415caeb535cd4ec9d23d6608630dd00a9db5db8faef4621ccb2e775844c7447a1a843ebac03eca6f329feabcd6560b80aacf7a54a298548827c9d75e1450fcf7e53dac37c0f7fd25d509c342c23bda0619504b28ec903c56c87\np &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307026173067\nq &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307046219549\nr &#x3D; 1475203612633975218848450285487339190962027688336790188873776418606441616307129708089\ne &#x3D; 0x10001\nphi &#x3D; (p - 1) * (q - 1) * (r - 1)\nd &#x3D; gmpy2.invert(e, phi)\nc &#x3D; 0x4920616D207375726520697420697320666C3467\nm &#x3D; gmpy2.powmod(c, d, n)\ns &#x3D; hex(m)[2:]\nflag &#x3D; &quot;&quot;\nfor i in range(0, len(s), 2):\n    tmp &#x3D; int(s[i:i + 2], 16)\n    if tmp &lt; 100:\n        flag +&#x3D; &quot;0&quot;\n    flag +&#x3D; str(tmp)\nprint(flag)</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">037087131219012107229231067248093076089082070175138132195124126254031088197066063081248248223201185154047168242228140155089071245228045160218140167117182217137118206104215018068031237111113041220252131252040018130017184197145113066057103096226240251147039224115177108218078236161028053035089246229073211242029209057</code></pre>\n\n<p>输入程序中验证正确</p>\n<h1 id=\"强网杯\"><a href=\"#强网杯\" class=\"headerlink\" title=\"强网杯\"></a>强网杯</h1><h2 id=\"GameMaster\"><a href=\"#GameMaster\" class=\"headerlink\" title=\"GameMaster\"></a>GameMaster</h2><p>拿到题目三个文件</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803161217284.png\" alt=\"image-20220803161217284\"></p>\n<p>核心文件BlackjackConsole.exe易知是基于.NET框架，c#编写的文件</p>\n<p>所以我们用神器dnSpy打开它</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803161838746.png\" alt=\"image-20220803161838746\"></p>\n<p>进入Program分析，因为c#也是面对对象的，所以有java基础的话看代码还是比较好懂的</p>\n<p>单独分析19行到23行这几句代码，因为它非常显眼，对题目中的”gamemessage”文件进行了操作</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">19\t\t\tFileStream fileStream &#x3D; File.OpenRead(&quot;gamemessage&quot;);\n20\t\t\tint num &#x3D; (int)fileStream.Length;\n21\t\t\tProgram.memory &#x3D; new byte[num];\n22\t\t\tfileStream.Position &#x3D; 0L;\n23\t\t\tfileStream.Read(Program.memory, 0, num);</code></pre>\n\n<p>就是将gamemessage里的内容读取到了新创的的一个byte数组memory中</p>\n<p>接着往下分析，这些是游戏初始化的内容，不是重点，一直往下滑发现这一段</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">567\t\t\t\tfor (int i &#x3D; 0; i &lt; Program.memory.Length; i++)\n568\t\t\t\t&#123;\n569\t\t\t\t\tbyte[] array &#x3D; Program.memory;\n570\t\t\t\t\tint num &#x3D; i;\n571\t\t\t\t\tarray[num] ^&#x3D; 34;\n572\t\t\t\t&#125;\n573\t\t\t\tEnvironment.SetEnvironmentVariable(&quot;AchivePoint1&quot;, game.Player.Balance.ToString());</code></pre>\n\n<p>这一段对memory进行了异或34的操作</p>\n<p>继续往下，发现</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">813\t            byte[] key &#x3D; new byte[]\n814             &#123;\n815                 66,\n816                 114,\n817                 97,\n818                 105,\n819                 110,\n820                 115,\n821                 116,\n822                 111,\n823                 114,\n824                 109,\n825                 105,\n826                 110,\n827                 103,\n828                 33,\n829                 33,\n830                 33\n831             &#125;;\n832             ICryptoTransform cryptoTransform &#x3D; new RijndaelManaged\n833             &#123;\n834                 Key &#x3D; key,\n835                 Mode &#x3D; CipherMode.ECB,\n836                 Padding &#x3D; PaddingMode.Zeros\n837             &#125;.CreateDecryptor();\n838             Program.m &#x3D; cryptoTransform.TransformFinalBlock(Program.memory, 0, Program.memory.Length);\n839             Environment.SetEnvironmentVariable(&quot;AchivePoint2&quot;, game.Player.Balance.ToString());</code></pre>\n\n<p>key数组，ECB模式，Zeros填充，对memory进行加密，查文档得知此为AES加密</p>\n<p>既然知道对gamemessage进行了什么操作，那么我们开始复现这两个操作</p>\n<p>首先是读取gamemessage，将其对34进行异或得到gamemessage_2文件</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">with open(&#39;gamemessage&#39;,&#39;rb&#39;) as f:\n    with open(&#39;gamemessage_2&#39;,&#39;wb&#39;) as f_2:\n        b&#x3D;f.read()\n        for i in range(len(b)):\n            f_2.write((b[i] ^ 34).to_bytes(1,&#39;little&#39;))</code></pre>\n\n<p>再对其进行AES解密，密钥为b’Brainstorming!!!’，ECB模式，Zeros填充</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803174116415.png\" alt=\"image-20220803174116415\"></p>\n<p>将解密出来的数据写入文件gamemessage_AES中，再用010 editor打开</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803174237233.png\" alt=\"image-20220803174237233\"></p>\n<p>发现头部很多可疑信息类似系统API的东西</p>\n<p>可以用binwalk扫一下</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803174756411.png\" alt=\"image-20220803174756411\"></p>\n<p>果然发现在0x13EB处有PE文件头标志”MZ”</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220803175030625.png\" alt=\"image-20220803175030625\"></p>\n<p>直接把”MZ”之前的数据删掉，得到新的PE文件，它仍是.NET框架下的文件，再用dnSpy打开它</p>\n<p>发现这么段代码</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">using System;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace T1Class&#123;\n\t&#x2F;&#x2F; Token: 0x02000002 RID: 2\n\tpublic class T1&#123;\n\t\t&#x2F;&#x2F; Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250\n\t\tprivate static void Check1(ulong x, ulong y, ulong z, byte[] KeyStream)&#123;\n\t\t\tint num &#x3D; -1;\n\t\t\tfor (int i &#x3D; 0; i &lt; 320; i++)&#123;\n\t\t\t\tx &#x3D; (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1UL) | x &lt;&lt; 1);\n\t\t\t\ty &#x3D; (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1UL) | y &lt;&lt; 1);\n\t\t\t\tz &#x3D; (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1UL) | z &lt;&lt; 1);\n\t\t\t\tbool flag &#x3D; i % 8 &#x3D;&#x3D; 0;\n\t\t\t\tif (flag)&#123;\n\t\t\t\t\tnum++;\n\t\t\t\t&#125;\n\t\t\t\tKeyStream[num] &#x3D; (byte)((long)((long)KeyStream[num] &lt;&lt; 1) | (long)((ulong)((uint)((z &gt;&gt; 32 &amp; 1UL &amp; (x &gt;&gt; 30 &amp; 1UL)) ^ (((z &gt;&gt; 32 &amp; 1UL) ^ 1UL) &amp; (y &gt;&gt; 31 &amp; 1UL))))));\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Token: 0x06000002 RID: 2 RVA: 0x00002110 File Offset: 0x00000310\n\t\tprivate static void ParseKey(ulong[] L, byte[] Key)&#123;\n\t\t\tfor (int i &#x3D; 0; i &lt; 3; i++)&#123;\n\t\t\t\tfor (int j &#x3D; 0; j &lt; 4; j++)&#123;\n\t\t\t\t\tKey[i * 4 + j] &#x3D; (byte)(L[i] &gt;&gt; j * 8 &amp; 255UL);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; Token: 0x06000003 RID: 3 RVA: 0x0000215C File Offset: 0x0000035C\n\t\tpublic T1()&#123;\n\t\t\ttry&#123;\n\t\t\t\tstring environmentVariable &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint1&quot;);\n\t\t\t\tstring environmentVariable2 &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint2&quot;);\n\t\t\t\tstring environmentVariable3 &#x3D; Environment.GetEnvironmentVariable(&quot;AchivePoint3&quot;);\n\t\t\t\tbool flag &#x3D; environmentVariable &#x3D;&#x3D; null || environmentVariable2 &#x3D;&#x3D; null || environmentVariable3 &#x3D;&#x3D; null;\n\t\t\t\tif (!flag)&#123;\n\t\t\t\t\tulong num &#x3D; ulong.Parse(environmentVariable);\n\t\t\t\t\tulong num2 &#x3D; ulong.Parse(environmentVariable2);\n\t\t\t\t\tulong num3 &#x3D; ulong.Parse(environmentVariable3);\n\t\t\t\t\tulong[] array &#x3D; new ulong[3];\n\t\t\t\t\tbyte[] array2 &#x3D; new byte[40];\n\t\t\t\t\tbyte[] array3 &#x3D; new byte[40];\n\t\t\t\t\tbyte[] array4 &#x3D; new byte[12];\n\t\t\t\t\tbyte[] first &#x3D; new byte[]&#123;\n\t\t\t\t\t\t101,5,80,213,163,26,59,38,19,6,173,189,198,166,140,183,42,247,223,24,106,20,145,37,24,7,22,191,110,179,227,5,62,9,13,17,65,22,37,5\n\t\t\t\t\t&#125;;\n\t\t\t\t\tbyte[] array5 &#x3D; new byte[]&#123;\n\t\t\t\t\t\t60,100,36,86,51,251,167,108,116,245,207,223,40,103,34,62,22,251,227\n\t\t\t\t\t&#125;;\n\t\t\t\t\tarray[0] &#x3D; num;\n\t\t\t\t\tarray[1] &#x3D; num2;\n\t\t\t\t\tarray[2] &#x3D; num3;\n\t\t\t\t\tT1.Check1(array[0], array[1], array[2], array2);\n\t\t\t\t\tbool flag2 &#x3D; first.SequenceEqual(array2);\n\t\t\t\t\tif (flag2)&#123;\n\t\t\t\t\t\tT1.ParseKey(array, array4);\n\t\t\t\t\t\tfor (int i &#x3D; 0; i &lt; array5.Length; i++)&#123;\n\t\t\t\t\t\t\tarray5[i] ^&#x3D; array4[i % array4.Length];\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tMessageBox.Show(&quot;flag&#123;&quot; + Encoding.Default.GetString(array5) + &quot;&#125;&quot;, &quot;Congratulations!&quot;, MessageBoxButtons.OK);\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcatch (Exception)&#123;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>逻辑大致如下：求flag-&gt;<strong>已知array5</strong>-&gt;求array4-&gt;ParseKey函数-&gt;求array-&gt;Check1函数-&gt;求array2-&gt;<strong>已知first</strong></p>\n<p>根据这位师傅的wp</p>\n<p>[2022强网杯 ”Reverse“ WP](<a href=\"https://blog.jamiexu.cn/2022/08/01/%E3%80%90CTF&WriteUP&Re%E3%80%912022%E5%BC%BA%E7%BD%91%E6%9D%AF\">https://blog.jamiexu.cn/2022/08/01/【CTF&amp;WriteUP&amp;Re】2022强网杯</a> ”Reverse“ WriteUp&#x2F;)</p>\n<p>exp求解array</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import z3\n\nfirst &#x3D; [\n  101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106, 20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5\n]\narray2 &#x3D; [0] * len(first)\nx &#x3D; z3.BitVec(&quot;x&quot;, 64)\ny &#x3D; z3.BitVec(&quot;y&quot;, 64)\nz &#x3D; z3.BitVec(&quot;z&quot;, 64)\nnum &#x3D; -1\nfor i in range(320):\n    x &#x3D; (((x &gt;&gt; 29 ^ x &gt;&gt; 28 ^ x &gt;&gt; 25 ^ x &gt;&gt; 23) &amp; 1) | x &lt;&lt; 1)\n    y &#x3D; (((y &gt;&gt; 30 ^ y &gt;&gt; 27) &amp; 1) | y &lt;&lt; 1)\n    z &#x3D; (((z &gt;&gt; 31 ^ z &gt;&gt; 30 ^ z &gt;&gt; 29 ^ z &gt;&gt; 28 ^ z &gt;&gt; 26 ^ z &gt;&gt; 24) &amp; 1) | z &lt;&lt; 1)\n    if i % 8 &#x3D;&#x3D; 0:\n        num +&#x3D; 1\n    array2[num] &#x3D; ((array2[num] &lt;&lt; 1) | (z &gt;&gt; 32 &amp; 1 &amp; (x &gt;&gt; 30 &amp; 1) ^ ((z &gt;&gt; 32 &amp; 1) ^ 1) &amp; (y &gt;&gt; 31 &amp; 1)))\n\nsolver &#x3D; z3.Solver()\nfor i in range(len(first)):\n    solver.add(first[i] &#x3D;&#x3D; array2[i])\n\nif solver.check() &#x3D;&#x3D; z3.sat:\n    model &#x3D; solver.model()\n    print(model)\n \n[y &#x3D; 868387187, x &#x3D; 156324965, z &#x3D; 3131229747]</code></pre>\n\n<p>最后直接异或就行了</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">array &#x3D; [156324965, 868387187, 3131229747]\narray4 &#x3D; [0] * 12\nfor i in range(3):\n    for j in range(4):\n        array4[i * 4 + j] &#x3D; (array[i] &gt;&gt; j * 8 &amp; 255)\n\narray5 &#x3D; [60, 100, 36, 86, 51, 251, 167, 108, 116, 245, 207, 223, 40, 103, 34, 62, 22, 251, 227]\nfor i in range(len(array5)):\n    print(chr(array5[i] ^ array4[i % len(array4)]), end&#x3D;&#39;&#39;)</code></pre>\n\n<p><code>Y0u_@re_G3meM3s7er!</code></p>\n<h2 id=\"easyre\"><a href=\"#easyre\" class=\"headerlink\" title=\"easyre\"></a>easyre</h2><p>题目的提示是flag藏在输入里面，先放在一边，可能会用上</p>\n<p>拿到源文件，查一下是64位elf文件放进ida64里</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__int64 __fastcall sub_4021BB(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)\n&#123;\n  double v10; &#x2F;&#x2F; xmm4_8\n  double v11; &#x2F;&#x2F; xmm5_8\n  unsigned int v13; &#x2F;&#x2F; [rsp+1Ch] [rbp-4h]\n\n  sub_402150();\n  v13 &#x3D; sub_44B420();\n  if ( v13 )\n  &#123;\n    sub_401F2F(v13);\n    sub_40C3F0((__int64)&quot;re3&quot;);\n  &#125;\n  else\n  &#123;\n    sub_44CC50(0LL, 0LL, 0LL, 0LL);\n    sub_44B680((__int64)&quot;re3&quot;, (__int64)&quot;re3&quot;, a3, a4, a5, a6, v10, v11, a9, a10, *(_QWORD *)(a2 + 8), 0LL);\n  &#125;\n  return 0LL;\n&#125;</code></pre>\n\n<p>进入第一个函数sub_402150()看看</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__int64 sub_402150()\n&#123;\n  __int64 v1; &#x2F;&#x2F; [rsp+8h] [rbp-8h]\n\n  v1 &#x3D; sub_40CFA0(&quot;re3&quot;, &quot;wb&quot;);\n  sub_40CFB0(&amp;unk_4BC380, 1LL, (unsigned int)dword_4C2070, v1);\n  sub_40C920(v1);\n  return sub_44BE20(&quot;re3&quot;, 511LL);\n&#125;</code></pre>\n\n<p>发现它是在写一个re3的文件，而unk_4BC380这个地址含有明显的elf文件头，后面的dword_4C2070为长度：0x5cf0</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220804124228271.png\" alt=\"image-20220804124228271\"></p>\n<p>那么我们把这个re3提出来</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import idc\nstart_addr &#x3D; 0x4BC380\nend_addr &#x3D; start_addr + 0x5cf0\nf &#x3D; open(&quot;re3&quot;,&quot;wb&quot;)\nfor addr in range(startaddr, endaddr):\n    f.write(idc.get_wide_byte(addr).to_bytes(1, &#39;little&#39;))\nf.close()</code></pre>\n\n<p>得到的re3也是一个64位elf文件，同样放进ida64中，main函数如下</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220804154635819.png\" alt=\"image-20220804154635819\"></p>\n<p>先试一下按c转换成代码，再按p创建函数，成功得到主函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__int64 __fastcall main(int a1, char **a2, char **a3)\n&#123;\n  struct __jmp_buf_tag env[1]; &#x2F;&#x2F; [rsp+10h] [rbp-850h] BYREF\n  struct __jmp_buf_tag v5[1]; &#x2F;&#x2F; [rsp+E0h] [rbp-780h] BYREF\n  struct __jmp_buf_tag v6[1]; &#x2F;&#x2F; [rsp+1B0h] [rbp-6B0h] BYREF\n  struct __jmp_buf_tag v7[1]; &#x2F;&#x2F; [rsp+280h] [rbp-5E0h] BYREF\n  char v8[640]; &#x2F;&#x2F; [rsp+350h] [rbp-510h] BYREF\n  char v9[636]; &#x2F;&#x2F; [rsp+5D0h] [rbp-290h] BYREF\n  int v10; &#x2F;&#x2F; [rsp+84Ch] [rbp-14h]\n  int v11; &#x2F;&#x2F; [rsp+850h] [rbp-10h]\n  int v12; &#x2F;&#x2F; [rsp+854h] [rbp-Ch]\n  int v13; &#x2F;&#x2F; [rsp+858h] [rbp-8h]\n  int v14; &#x2F;&#x2F; [rsp+85Ch] [rbp-4h]\n  __int64 savedregs; &#x2F;&#x2F; [rsp+860h] [rbp+0h] BYREF\n\n  v14 &#x3D; 1;\n  if ( a1 !&#x3D; 2 )\n    return 0LL;\n  sub_2490(a2[1]);\n  ((void (__fastcall *)(_BYTE *, char *, char *))loc_21F9)(byte_55C0, v9, v8);\n  v13 &#x3D; _setjmp(env);\n  if ( v13 &lt;&#x3D; 24 )\n  &#123;\n    v11 &#x3D; _setjmp(v5);\n    if ( v11 &lt; byte_50A0[25 * v13] )\n    &#123;\n      if ( byte_50A0[25 * v13 + 1 + v11] !&#x3D; *((char *)&amp;savedregs + 25 * v13 + v11 - 655) )\n        v14 &#x3D; 0;\n      longjmp(v5, v11 + 1);\n    &#125;\n    longjmp(env, v13 + 1);\n  &#125;\n  v12 &#x3D; _setjmp(v6);\n  if ( v12 &lt;&#x3D; 24 )\n  &#123;\n    v10 &#x3D; _setjmp(v7);\n    if ( v10 &lt; byte_5320[25 * v12] )\n    &#123;\n      if ( byte_5320[25 * v12 + 1 + v10] !&#x3D; *((char *)&amp;savedregs + 25 * v12 + v10 - 1295) )\n        v14 &#x3D; 0;\n      longjmp(v7, v10 + 1);\n    &#125;\n    longjmp(v6, v12 + 1);\n  &#125;\n  if ( v14 &#x3D;&#x3D; 1 )\n    puts(&quot;GOOD JOB&quot;);\n  return 0LL;\n&#125;</code></pre>\n\n<p>两个二维数组byte_50A0和byte_5320</p>\n<p>提出来发现是个25*25的数织游戏</p>\n<p>结合之前的提示，解出来这个游戏应该就能拿到flag</p>\n<p><a href=\"https://handsomeone.github.io/Nonogram/\">https://handsomeone.github.io/Nonogram/</a></p>\n<p>通过这个在线网站解出答案</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220804155201019.png\" alt=\"image-20220804155201019\"></p>\n<p>emmm，被坑了，不对，回到ida，用分析主函数的方法又分析到几个可疑的函数</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">char *sub_265C()\n&#123;\n  unsigned int v0; &#x2F;&#x2F; eax\n  char *result; &#x2F;&#x2F; rax\n  char v2[639]; &#x2F;&#x2F; [rsp+0h] [rbp-300h] BYREF\n  char needle[2]; &#x2F;&#x2F; [rsp+27Fh] [rbp-81h] BYREF\n  char v4; &#x2F;&#x2F; [rsp+281h] [rbp-7Fh]\n  char v5[4]; &#x2F;&#x2F; [rsp+282h] [rbp-7Eh] BYREF\n  __int16 v6; &#x2F;&#x2F; [rsp+286h] [rbp-7Ah]\n  char v7[4]; &#x2F;&#x2F; [rsp+288h] [rbp-78h] BYREF\n  __int16 v8; &#x2F;&#x2F; [rsp+28Ch] [rbp-74h]\n  char v9[2]; &#x2F;&#x2F; [rsp+28Eh] [rbp-72h] BYREF\n  char v10; &#x2F;&#x2F; [rsp+290h] [rbp-70h]\n  char format[8]; &#x2F;&#x2F; [rsp+291h] [rbp-6Fh] BYREF\n  int v12; &#x2F;&#x2F; [rsp+299h] [rbp-67h]\n  __int16 v13; &#x2F;&#x2F; [rsp+29Dh] [rbp-63h]\n  char v14; &#x2F;&#x2F; [rsp+29Fh] [rbp-61h]\n  char haystack[16]; &#x2F;&#x2F; [rsp+2A0h] [rbp-60h] BYREF\n  char s[32]; &#x2F;&#x2F; [rsp+2B0h] [rbp-50h] BYREF\n  __int64 v17; &#x2F;&#x2F; [rsp+2D0h] [rbp-30h]\n  int v18; &#x2F;&#x2F; [rsp+2DCh] [rbp-24h]\n  FILE *stream; &#x2F;&#x2F; [rsp+2E0h] [rbp-20h]\n  int n; &#x2F;&#x2F; [rsp+2E8h] [rbp-18h]\n  int m; &#x2F;&#x2F; [rsp+2ECh] [rbp-14h]\n  int l; &#x2F;&#x2F; [rsp+2F0h] [rbp-10h]\n  int k; &#x2F;&#x2F; [rsp+2F4h] [rbp-Ch]\n  int j; &#x2F;&#x2F; [rsp+2F8h] [rbp-8h]\n  int i; &#x2F;&#x2F; [rsp+2FCh] [rbp-4h]\n\n  *(_QWORD *)format &#x3D; 0xEAABA1EDE1FCFEA1LL;\n  v12 &#x3D; -268763743;\n  v13 &#x3D; -1030;\n  v14 &#x3D; -3;\n  *(_WORD *)v9 &#x3D; -5399;\n  v10 &#x3D; -20;\n  *(_DWORD *)v7 &#x3D; -268633374;\n  v8 &#x3D; -5139;\n  *(_DWORD *)v5 &#x3D; -268633347;\n  v6 &#x3D; -5139;\n  *(_WORD *)needle &#x3D; -5401;\n  v4 &#x3D; -17;\n  for ( i &#x3D; 0; i &lt;&#x3D; 14; ++i )\n    format[i] ^&#x3D; 0x8Eu;\n  for ( j &#x3D; 0; j &lt;&#x3D; 2; ++j )\n    v9[j] ^&#x3D; 0x8Eu;\n  for ( k &#x3D; 0; k &lt;&#x3D; 5; ++k )\n    v7[k] ^&#x3D; 0x8Eu;\n  for ( l &#x3D; 0; l &lt;&#x3D; 5; ++l )\n    v5[l] ^&#x3D; 0x8Eu;\n  for ( m &#x3D; 0; m &lt;&#x3D; 5; ++m )\n    needle[m] ^&#x3D; 0x8Eu;\n  v0 &#x3D; getppid();\n  snprintf(s, 0x1EuLL, format, v0);\n  stream &#x3D; fopen(s, &quot;r&quot;);\n  fgets(haystack, 16, stream);\n  fclose(stream);\n  result &#x3D; (char *)(strstr(haystack, needle) || strstr(haystack, v9) || strstr(haystack, v7) || strstr(haystack, v5));\n  v18 &#x3D; (int)result;\n  if ( !(_DWORD)result )\n  &#123;\n    qmemcpy(v2, &amp;unk_32A0, 0x271uLL);\n    result &#x3D; (char *)&amp;unk_5834 - 1940;\n    v17 &#x3D; (__int64)&amp;unk_5834 - 1940;\n    for ( n &#x3D; 0; n &lt;&#x3D; 24; ++n )\n      result &#x3D; (char *)memcpy((void *)(25 * n + v17), &amp;v2[25 * n], (unsigned __int8)v2[25 * n] + 1);\n  &#125;\n  return result;\n&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__int64 sub_257D()\n&#123;\n  char v1[640]; &#x2F;&#x2F; [rsp+0h] [rbp-290h] BYREF\n  __int64 v2; &#x2F;&#x2F; [rsp+280h] [rbp-10h]\n  int i; &#x2F;&#x2F; [rsp+28Ch] [rbp-4h]\n\n  qmemcpy(v1, &amp;unk_3020, 0x271uLL);\n  v2 &#x3D; (__int64)&amp;unk_5838 - 1304;\n  for ( i &#x3D; 0; i &lt;&#x3D; 24; ++i )\n    memcpy((void *)(25 * i + v2), &amp;v1[25 * i], (unsigned __int8)v1[25 * i] + 1);\n  return nullsub_2();\n&#125;</code></pre>\n\n<p>sub_265C里面的&amp;unk_32A0和sub_257D里面的&amp;unk_3020也是25*25的二维数组非常可疑</p>\n<p>提出来当作数织的行和列再解一遍</p>\n<p><img src=\"20220803-hws-qwb-recurrent/image-20220804155510816.png\" alt=\"image-20220804155510816\"></p>\n<p>嗯，对味</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">FLAG&#123;I LOVE PLAY ctf_QWB2022&#125;</code></pre>","feature":false,"text":"2022-HWS&amp;强网杯-复现 HWS ​ re2 ​ re3 强网杯 ​ GameMaster ​ easyre HWSre2拿到源文件re2.exe...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"Write Up","slug":"Write-Up","count":3,"path":"api/categories/Write-Up.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"},{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"},{"name":"reverse","slug":"reverse","count":4,"path":"api/tags/reverse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HWS\"><span class=\"toc-text\">HWS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#re2\"><span class=\"toc-text\">re2</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#re3\"><span class=\"toc-text\">re3</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E7%BD%91%E6%9D%AF\"><span class=\"toc-text\">强网杯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GameMaster\"><span class=\"toc-text\">GameMaster</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#easyre\"><span class=\"toc-text\">easyre</span></a></li></ol></li></ol>","author":{"name":"y9nhjy","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/73747088?v=4","link":"https://y9nhjy.github.io","description":"手握日月摘星辰","socials":{"github":"https://github.com/y9nhjy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_51280668","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"2022-HWS夏令营线下赛","uid":"63c1d1c611bd361be9cbbdc1ef690d2f","slug":"20220815-hws-live","date":"2022-08-15T03:00:00.000Z","updated":"2023-08-16T10:22:17.854Z","comments":true,"path":"api/articles/20220815-hws-live.json","keywords":null,"cover":[],"text":"2022-HWS夏令营线下赛 比赛：HWS计划第五期-2022硬件安全在线夏令营线下赛 时间：2022-08-15 17:00:00~2022-08-01 22...","link":"","photos":[],"count_time":{"symbolsCount":286,"symbolsTime":"1 mins."},"categories":[{"name":"Write Up","slug":"Write-Up","count":3,"path":"api/categories/Write-Up.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"},{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"},{"name":"reverse","slug":"reverse","count":4,"path":"api/tags/reverse.json"}],"author":{"name":"y9nhjy","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/73747088?v=4","link":"https://y9nhjy.github.io","description":"手握日月摘星辰","socials":{"github":"https://github.com/y9nhjy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_51280668","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"2022-HWS夏令营预选赛","uid":"ebb392945466e3b28411a4ab0abfa6f9","slug":"20220801-hws-qualifier","date":"2022-08-01T03:00:00.000Z","updated":"2023-08-16T08:25:20.550Z","comments":true,"path":"api/articles/20220801-hws-qualifier.json","keywords":null,"cover":[],"text":"2022-HWS夏令营预选赛 比赛：HWS计划第五期-2022硬件安全在线夏令营线上预选赛 时间：2022-07-29 09:00:00~2022-08-01 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Write Up","slug":"Write-Up","count":3,"path":"api/categories/Write-Up.json"}],"tags":[{"name":"ctf","slug":"ctf","count":3,"path":"api/tags/ctf.json"},{"name":"wp","slug":"wp","count":3,"path":"api/tags/wp.json"},{"name":"reverse","slug":"reverse","count":4,"path":"api/tags/reverse.json"}],"author":{"name":"y9nhjy","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/73747088?v=4","link":"https://y9nhjy.github.io","description":"手握日月摘星辰","socials":{"github":"https://github.com/y9nhjy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/weixin_51280668","juejin":"","customs":{}}},"feature":false}}